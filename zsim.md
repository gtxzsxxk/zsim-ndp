# zsimåˆ†æ

## å¯åŠ¨æµç¨‹

### zsim harness

ç¼–è¯‘zsimé¡¹ç›®ä¼šäº§ç”Ÿä¸¤ä¸ªäºŒè¿›åˆ¶ï¼Œä¸€ä¸ªæ˜¯libzsim.soï¼Œä¸€ä¸ªæ˜¯zsimã€‚zsimçš„æœ¬ä½“æ˜¯zsim_harness.cppï¼Œè€Œä¸PINæœ‰å…³çš„zsim.cppä¼šè¢«ç¼–åˆ°libzsim.soå†…ã€‚

zsim_harnessçš„mainå‡½æ•°å†…ï¼Œæ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°å¾—åˆ°configFileçš„è·¯å¾„ï¼Œç„¶åè®¾ç½®æ¯ä¸ªsignalçš„å¤„ç†ï¼Œå‡ ä¹åªè¦æ˜¯signalå°±ç›´æ¥é‡å¼€ï¼ŒæŠŠæ•´ä¸ªè¿›ç¨‹æ ‘éƒ½å¹²æ‰ã€‚

ç„¶åæ ¹æ®sim.gmMBytesç”³è¯·å†…å­˜ï¼Œç„¶åä½¿ç”¨**PinCmd**ç±»æ¥åŠ è½½libzsim.soï¼Œç”Ÿæˆç›®æ ‡ç¨‹åºæ­£ç¡®çš„argsï¼Œå¾—åˆ°æ€»å…±çš„è¿›ç¨‹æ•°ï¼ˆä¹Ÿå°±æ˜¯éœ€è¦ä»¿çœŸå¤šå°‘ä¸ªç¨‹åºï¼Œåœ¨zsim.cfgä¸­ç”¨process0ã€process1è¿›è¡Œé…ç½®ï¼‰ï¼Œç„¶ååˆ›å»ºè¿›ç¨‹ã€‚

è¿›å…¥åˆ›å»ºè¿›ç¨‹çš„å‡½æ•°ï¼ˆLaunchProcessï¼‰åï¼Œä¼šè°ƒç”¨forkåˆ›å»ºæ–°çš„è¿›ç¨‹ï¼Œparentè¿›ç¨‹ä¼šç›´æ¥æ‘¸é±¼è¿”å›ï¼Œè€Œchildè¿›ç¨‹å°±è¦è°ƒç”¨execvpè¿›å…¥ç›®æ ‡ç¨‹åºï¼Œé¡ºä¾¿è¿›å…¥zsim.cppçš„mainå‡½æ•°ã€‚

è¿™ä¸ªæ—¶å€™parentè¿›ç¨‹å°±ä¼šå¼€å§‹æ‘¸é±¼ï¼Œç­‰å¾…å­è¿›ç¨‹ç»“æŸã€‚ä½œä¸ºå¤–éƒ¨è§‚å¯Ÿè€…ï¼Œç›‘æ§æ¨¡æ‹Ÿæ˜¯å¦â€œå¡ä½â€ã€‚wait() æ‰€æœ‰é€€å‡ºçš„å­è¿›ç¨‹ï¼Œé˜²æ­¢å®ƒä»¬å˜â€œåƒµå°¸â€ã€‚å®šæœŸæ‰“å°å¿ƒè·³ï¼Œå¹¶åœ¨æ¨¡æ‹Ÿå™¨å´©æºƒæ—¶æä¾›ä¸€äº›çº¿ç´¢ã€‚

### zinfo

**GlobSimInfo**æ˜¯ä¸€ä¸ªåŸºäºå…±äº«å†…å­˜çš„è¿›ç¨‹é—´çŠ¶æ€ç®¡ç†ç±»ã€‚

### libzsim.so

è¿›å…¥åˆ°libzsim.soåï¼Œå°†æ‰§è¡Œzsim.cppçš„mainå‡½æ•°ã€‚

é¦–å…ˆæ‰§è¡Œäº†PIN_InitSymbolså’ŒPIN_Initï¼Œåˆå§‹åŒ–PINã€‚ç„¶åè°ƒç”¨PIN_AddInternalExceptionHandlerè®¾ç½®InternalExceptionHandlerå‡½æ•°ä¸ºå¼‚å¸¸handlerï¼Œæœ¬è´¨ä¸Šå°±æ˜¯backtraceç„¶åç»“æŸè¿›ç¨‹ã€‚

ç„¶åä¼šè·å–ç›®å‰å±äºç¬¬å‡ ä¸ªè¿›ç¨‹ï¼Œå¦‚æœæ˜¯ç¬¬0ä¸ªè¿›ç¨‹ï¼Œå°±å¼€å§‹æ‰§è¡ŒSimInitå‡½æ•°ã€‚

#### SimInit

SimInitå‡½æ•°ä¼šåˆå§‹åŒ–zinfoï¼Œé…ç½®å¥½ä»¿çœŸçš„æ ¸å¿ƒæ•°ï¼Œè®¾ç½®å¥½sim.domainsã€sim.contentionThreadsç­‰é€‰é¡¹ï¼Œåˆå§‹åŒ–**ContentionSim**ç±»ï¼Œ

ç„¶åé…ç½®sim.phaseLengthã€sim.statsPhaseIntervalã€sys.frequencyç­‰ã€‚

ç„¶ååˆå§‹åŒ–ä¸€ä¸ª**EventQueue**ç±»ï¼Œå¦‚æœæ²¡æœ‰è¢«é…ç½®æˆtraceDrivenæ¨¡å¼ï¼Œé‚£ä¹ˆå°±åˆå§‹åŒ–**Scheduler**ç±»ã€‚

è°ƒç”¨InitGlobalStatsåˆå§‹åŒ–å…¨å±€çŠ¶æ€ã€‚

åˆå§‹åŒ–**AggregateStat**ç±»ï¼Œåˆå§‹åŒ–**PortVirtualizer**ç±»ã€‚

ç„¶åè°ƒç”¨CreateProcessTreeåˆ›å»ºè¿›ç¨‹æ ‘ã€‚è°ƒç”¨InitNUMAè®¾ç½®å’ŒéªŒè¯NUMAæ¨¡æ‹Ÿç¯å¢ƒï¼Œç„¶ååˆ›å»º**NUMAMap**ç±»ã€‚

è°ƒç”¨InitSystemåˆå§‹åŒ–cacheã€coreå’Œmemory controllerã€‚ä¼šæŠŠè¿™äº›çš„hierarchyç»„åˆæˆä¸€ä¸ªmapå’Œparentã€childçš„å…³ç³»ï¼ŒInitSystem å‡½æ•° new å‡ºäº†ä¸€ç³»åˆ—æ ¸å¿ƒç±»ï¼Œä¸»è¦åŒ…æ‹¬ï¼šSimpleCoreã€TimingCore æˆ– OOOCoreï¼ˆCPU æ ¸å¿ƒï¼‰ï¼ŒBaseCache çš„å„ç§å­ç±»ï¼ˆç¼“å­˜ï¼‰ï¼ŒMemInterconnectã€MemRouter å’Œ MemInterconnectInterfaceï¼ˆæ€»çº¿/äº’è¿ï¼‰ï¼Œä»¥åŠ BuildMemoryController è¿”å›çš„ MemObjectï¼ˆå†…å­˜æ¡ï¼‰ã€‚è¿™äº› new å¥½çš„å¯¹è±¡å¹¶æ²¡æœ‰ä¸€ä¸ªç»Ÿä¸€çš„â€œå…¨å±€åˆ—è¡¨â€ï¼›ç›¸åï¼Œå®ƒä»¬é€šè¿‡ setParents() å’Œ setChildren() æ–¹æ³•è¢«â€œç„Šæ¥â€åœ¨äº†ä¸€èµ·ã€‚æœ€ç»ˆï¼Œæ‰€æœ‰çš„ CPU æ ¸å¿ƒ æŒ‡é’ˆè¢«å­˜æ”¾åœ¨å…¨å±€çš„ zinfo->cores æ•°ç»„ä¸­ï¼Œè€Œç¼“å­˜ã€æ€»çº¿å’Œå†…å­˜åˆ™é€šè¿‡å½¼æ­¤çš„çˆ¶/å­æŒ‡é’ˆï¼Œæ„æˆäº†ä¸€ä¸ªä»æ ¸å¿ƒï¼ˆCoreï¼‰ç›´è¾¾å†…å­˜ï¼ˆMemoryï¼‰çš„å®Œæ•´ã€å¯éå†çš„å±‚çº§æ ‘ã€‚

å¦‚æœå®šä¹‰äº†ï¼Œå°±æ‰§è¡Œzinfo->sched->initStatsã€‚new **ProcessStats**ç±»ï¼Œnew **ProcStats**ç±»ï¼Œnew **VectorCounter**ç±»ä½œä¸ºzinfo->profHeartbeatsçš„å€¼ï¼Œå¤„ç†ä¸€äº›æ‚é¡¹åæ‰§è¡Œzinfo->contentionSim->postInitï¼Œå¹¶è®¾ç½®gm_set_glob_ptr(zinfo)ï¼Œå³å®ŒæˆSimInitã€‚

SimInitè°ƒç”¨ç»“æŸåï¼Œåˆå§‹åŒ–fPtrså’Œcidsã€‚fPtrsæ˜¯æ‰€æœ‰ä»¿çœŸthreadçš„å‡½æ•°æŒ‡é’ˆé›†åˆã€‚æ¯ä¸€ä¸ªthreadå¯¹åº”äº†è‡ªå·±çš„loadPtrã€storePtrã€bblPtrã€branchPtrã€predLoadPtrã€predStorePtrï¼Œè¿™äº›æ˜¯zsimä¸­å¯¹ä¸åŒä»¿çœŸæ•°æ®çš„å¤„ç†å‡½æ•°ã€‚cidsæ˜¯ç‰©ç†ä¸Šçš„æ ‡è¯†ç¬¦ï¼Œæ ‡è¯†ä»£è¡¨zsimæ¨¡æ‹Ÿçš„ç¡¬ä»¶CPUæ ¸å¿ƒï¼ˆcoreï¼‰ã€‚tid(Thread ID): é€»è¾‘æ ‡è¯†ç¬¦ã€‚ä»£è¡¨æ­£åœ¨æ¨¡æ‹Ÿçš„åº”ç”¨ç¨‹åºä¸­çš„çº¿ç¨‹ã€‚zsimä¸­è¿˜æœ‰ä¸€ä¸ªgidï¼Œå°±æ˜¯ä¸€ä¸ª32ä½çš„æ•´æ•°ï¼Œå®ƒçš„é«˜16ä½æ˜¯pidï¼Œä½16ä½æ˜¯tidã€‚

ç„¶åå¼€å§‹è°ƒç”¨VirtCaptureClocksè®¾ç½®è™šæ‹ŸåŒ–çš„**ClockDomainInfo**ç±»ã€‚

#### FFIInit

ç„¶åè°ƒç”¨FFIInitå‡½æ•°åœ¨è¿›ç¨‹startæ—¶åˆå§‹åŒ–Fast-Forward Intervalsã€‚è¿™ä¸ªå‡½æ•°è¯»å–ffiPointsåˆ—è¡¨ï¼ˆä¾‹å¦‚ [1M, 9M]ï¼‰ã€‚è®¾ç½®ç¬¬ä¸€ä¸ªæŒ‡ä»¤é™åˆ¶ ffiInstrsLimit = 1000000ã€‚æ­¤æ—¶ï¼Œæ¨¡æ‹Ÿå™¨å¤„äºNFF (è¯¦ç»†æ¨¡æ‹Ÿ) æ¨¡å¼ã€‚

è°ƒç”¨FFITrackNFFInterval()ã€‚è¿™ä¸ªå‡½æ•°â€œè®¾ç½®ä¸€ä¸ªé—¹é’Ÿâ€ã€‚å®ƒä½¿ç”¨makeAdaptiveEventåˆ›å»ºä¸€ä¸ªäº‹ä»¶ï¼Œæ’å…¥åˆ°zinfo->eventQueueä¸­ã€‚è¿™ä¸ªäº‹ä»¶å°†åœ¨ ffiInstrsLimitè¿™ä¹ˆå¤šï¼ˆå³100ä¸‡æ¡ï¼‰è¯¦ç»†æŒ‡ä»¤è¢«æ‰§è¡Œåè§¦å‘ã€‚è§¦å‘çš„æ˜¯ffiFire lambda(åˆ‡æ¢åˆ° FF)ï¼šå½“è¿™100ä¸‡æ¡è¯¦ç»†æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•ï¼Œ"é—¹é’Ÿ"å“èµ·ï¼ŒffiFireè¿™ä¸ªlambdaåŒ¿åå‡½æ•°è¢«æ‰§è¡Œã€‚å®ƒæ‰“å° "Entering fast-forward" å¹¶è°ƒç”¨ zinfo->procArray[p]->enterFastForward()ã€‚æ¨¡æ‹Ÿå™¨åˆ‡æ¢åˆ°FF(å¿«è¿›)æ¨¡å¼ã€‚FFIEntryBasicBlockä½œä¸ºè¿‡æ¸¡å‡½æ•°è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œå®ƒä¼šè°ƒç”¨FFIAdvance()ã€‚

ç„¶åæ‰§è¡ŒVirtInitå‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¸»è¦å°±æ˜¯patchç³»ç»Ÿè°ƒç”¨ï¼Œpatchäº†ä»¥ä¸‹éƒ¨åˆ†ï¼š

#### VirtInit

åˆå§‹åŒ–zsimçš„ç³»ç»Ÿè°ƒç”¨è™šæ‹ŸåŒ–åŠŸèƒ½ã€‚

1. ğŸ“ æ–‡ä»¶ç³»ç»Ÿ (fs.cpp) Syscalls: SYS_open, SYS_openatã€‚ç”¨é€”ï¼š æ‹¦æˆªæ–‡ä»¶æ‰“å¼€è¯·æ±‚ã€‚è¿™æ˜¯ä¸ºäº†æä¾›ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ˆpatchRootï¼‰ã€‚å½“ç¨‹åºå°è¯•è¯»å– /sys/devices/system/nodeï¼ˆNUMA æ‹“æ‰‘ï¼‰æˆ– /proc/cpuinfoï¼ˆCPU ä¿¡æ¯ï¼‰æ—¶ï¼Œzsim ä¼šæ‹¦æˆªè¿™ä¸ªè¯·æ±‚ï¼Œå¹¶ç»™å®ƒè¿”å›ä¸€ä¸ªä¼ªé€ çš„ã€æè¿°æ¨¡æ‹Ÿç³»ç»Ÿæ‹“æ‰‘çš„æ–‡ä»¶ã€‚

2. ğŸŒ ç«¯å£/ç½‘ç»œ (ports.cpp) Syscalls: SYS_bind, SYS_getsockname, SYS_connectã€‚ç”¨é€”ï¼š è™šæ‹ŸåŒ–ç½‘ç»œç«¯å£ã€‚è¿™å…è®¸å¤šä¸ª zsim æ¨¡æ‹Ÿçš„è¿›ç¨‹åœ¨æ¨¡æ‹Ÿçš„ç½‘ç»œä¸Šäº’ç›¸é€šä¿¡ï¼Œè€Œä¸ä¼šå ç”¨æˆ–å¹²æ‰°å®¿ä¸»æœºçš„çœŸå®ç½‘ç»œç«¯å£ã€‚

3. ğŸ–¥ï¸ CPU è™šæ‹ŸåŒ– (cpu.cpp) Syscalls: SYS_getcpu, SYS_sched_getaffinity, SYS_sched_setaffinityã€‚ç”¨é€”ï¼š å‘ç¨‹åºâ€œè°æŠ¥â€CPU ä¿¡æ¯ã€‚å½“ç¨‹åºè¯¢é—®â€œæˆ‘åœ¨å“ªä¸ªCPUä¸Šè¿è¡Œï¼Ÿâ€ï¼ˆgetcpuï¼‰æˆ–â€œæˆ‘å…è®¸åœ¨å“ªäº›CPUä¸Šè¿è¡Œï¼Ÿâ€ï¼ˆgetaffinityï¼‰æ—¶ï¼Œzsim ä¼šæ‹¦æˆªå®ƒï¼Œå¹¶æ ¹æ® Scheduler çš„è°ƒåº¦ï¼ˆgid -> cid çš„æ˜ å°„ï¼‰è¿”å›æ¨¡æ‹Ÿçš„ CPU æ ¸å¿ƒ IDï¼ˆcidï¼‰ï¼Œè€Œä¸æ˜¯å®¿ä¸»æœºçš„ CPU IDã€‚

4. ğŸ§  NUMA è™šæ‹ŸåŒ– (numa.cpp) Syscalls: SYS_get_mempolicy, SYS_set_mempolicy, SYS_mbind, SYS_munmap, SYS_mremap ç­‰ã€‚ç”¨é€”ï¼š è¿™æ˜¯ NUMAMap æœºåˆ¶çš„æ ¸å¿ƒã€‚zsim å¿…é¡»æ‹¦æˆªæ‰€æœ‰ç®¡ç†å†…å­˜ç­–ç•¥çš„è°ƒç”¨ã€‚set_mempolicy: å½“ç¨‹åºè®¾ç½®å†…å­˜ç­–ç•¥ï¼ˆå¦‚â€œæœ¬åœ°ä¼˜å…ˆâ€æˆ–â€œäº¤é”™â€ï¼‰æ—¶ï¼Œzsim æ‹¦æˆªå®ƒï¼Œå¹¶å°†è¿™ä¸ªç­–ç•¥ä¿å­˜åˆ° NUMAMap çš„ threadPolicy ä¸­ã€‚munmap: å½“ç¨‹åºé‡Šæ”¾å†…å­˜æ—¶ï¼Œzsim æ‹¦æˆªå®ƒï¼Œä»¥ä¾¿æ›´æ–° NUMAMap ä¸­çš„ PageMapï¼ˆé¡µ -> èŠ‚ç‚¹ï¼‰æ˜ å°„ã€‚

5. ğŸ›‘ çº¿ç¨‹æ§åˆ¶ (control.cpp) Syscalls: SYS_exit_groupã€‚ç”¨é€”ï¼š ä¼˜é›…åœ°ç»ˆæ­¢æ¨¡æ‹Ÿã€‚å½“è¢«æ¨¡æ‹Ÿçš„ç¨‹åºï¼ˆçš„ä¸»çº¿ç¨‹ï¼‰é€€å‡ºæ—¶ï¼Œzsim å¿…é¡»æ•è·è¿™ä¸ªäº‹ä»¶ï¼Œä»¥ä¾¿åœæ­¢æ‰€æœ‰æ¨¡æ‹Ÿç»„ä»¶ã€åˆ·æ–°æ‰€æœ‰ç»Ÿè®¡æ•°æ®å¹¶å¹²å‡€åœ°é€€å‡ºï¼Œè€Œä¸æ˜¯è®©æ•´ä¸ª Pin å·¥å…·å´©æºƒã€‚

6. â° æ—¶é—´ä¸è¶…æ—¶ (time.cpp, timeout.cpp) Syscalls: SYS_gettimeofday, SYS_time, SYS_nanosleep, SYS_futex, SYS_poll ç­‰ã€‚ç”¨é€”ï¼š æ—¶é—´è™šæ‹ŸåŒ–ã€‚è¿™æ˜¯æ¨¡æ‹Ÿå™¨æœ€å…³é”®çš„è¡¥ä¸ä¹‹ä¸€ã€‚è·å–æ—¶é—´ï¼š å½“ç¨‹åºè¯¢é—®â€œç°åœ¨å‡ ç‚¹äº†ï¼Ÿâ€ï¼ˆgettimeofdayï¼‰ï¼Œzsim ä¼šè¿”å›æ¨¡æ‹Ÿæ—¶é—´ï¼ˆå³ zinfo->globPhaseCyclesï¼‰ï¼Œè€Œä¸æ˜¯çœŸå®çš„æŒ‚é’Ÿæ—¶é—´ã€‚é˜»å¡/ç¡çœ ï¼š å½“ç¨‹åºè°ƒç”¨ nanosleep æˆ– futexï¼ˆç­‰å¾…é”ï¼‰æ—¶ï¼Œå®ƒæœ¬æ„æ˜¯â€œé˜»å¡â€è‡ªå·±ã€‚å¦‚æœ zsim è®©å®¿ä¸»æœº OS çœŸçš„é˜»å¡å®ƒï¼Œæ•´ä¸ªæ¨¡æ‹Ÿéƒ½ä¼šå¡ä½ã€‚zsim ä¼šæ‹¦æˆªè¿™ä¸ªè°ƒç”¨ï¼Œåœ¨ Scheduler ä¸­å°†è¯¥çº¿ç¨‹è®¾ä¸º SLEEPING æˆ– BLOCKED çŠ¶æ€ï¼Œç„¶åç»§ç»­æ¨è¿›æ¨¡æ‹Ÿæ—¶é—´ï¼Œç›´åˆ°æ»¡è¶³å”¤é†’æ¡ä»¶ã€‚

#### VdsoInit

åœ¨è°ƒç”¨å®ŒVirtInitå‡½æ•°åï¼Œå°±ä¼šå¼€å§‹è°ƒç”¨VdsoInitå‡½æ•°ã€‚VirtInit è´Ÿè´£æ‹¦æˆªæ™®é€šçš„ç³»ç»Ÿè°ƒç”¨ï¼ˆé‚£äº›ä¼šé™·å…¥å†…æ ¸çš„ï¼‰ï¼Œè€Œ VdsoInit è´Ÿè´£æ‹¦æˆªèµ°æ·å¾„çš„ç³»ç»Ÿè°ƒç”¨ï¼ˆé‚£äº›å®Œå…¨åœ¨ç”¨æˆ·æ€å®Œæˆçš„ï¼‰ã€‚ä¸»è¦é’ˆå¯¹clock_gettimeã€gettimeofdayã€timeã€getcpuã€‚

#### æ’æ¡©

åœ¨åˆå§‹åŒ–å®Œè™šæ‹ŸåŒ–åï¼Œå°±è¦è¿›è¡Œæ’æ¡©äº†ï¼Œæ’æ¡©çš„éƒ¨åˆ†å¦‚ä¸‹ï¼š

1. æ ¸å¿ƒæŒ‡ä»¤æµæ’æ¡©ã€‚ä½¿ç”¨TRACE_AddInstrumentFunctionå‡½æ•°ï¼Œæ¯å½“ Pin å‘ç°ä¸€ä¸ªæ–°çš„ Traceï¼Œå®ƒå°±ä¼šè°ƒç”¨ zsim çš„ Trace() å‡½æ•°ã€‚
2. çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ä½¿ç”¨PIN_AddThreadStartFunctionå‡½æ•°å’ŒPIN_AddThreadFiniFunctionå‡½æ•°ã€‚å½“ç›®æ ‡ç¨‹åº pthread_create æ—¶ï¼Œzsim éœ€è¦åœ¨è‡ªå·±çš„ Scheduler ä¸­æ³¨å†Œè¿™ä¸ªæ–°çº¿ç¨‹ï¼Œåˆ†é…ä¸€ä¸ª ThreadInfoï¼Œå¹¶ç»™å®ƒåˆ†é…ä¸€ä¸ªæ¨¡æ‹Ÿæ ¸å¿ƒ (cid)ã€‚Fini: å½“çº¿ç¨‹é€€å‡ºæ—¶ï¼Œzsim éœ€è¦å›æ”¶èµ„æºï¼Œå¹¶åœ¨ Scheduler ä¸­æ³¨é”€å®ƒã€‚å®ç°çš„å‡½æ•°æ˜¯ThreadStartå’ŒThreadFiniã€‚
3. ç³»ç»Ÿè°ƒç”¨æ‹¦æˆªã€‚ä½¿ç”¨PIN_AddSyscallEntryFunctionå‡½æ•°å’ŒPIN_AddSyscallExitFunctionå‡½æ•°ã€‚è°ƒç”¨çš„å‡½æ•°ä¸ºSyscallEnterå’ŒSyscallExitã€‚ä½¿ç”¨PIN_AddContextChangeFunctionå‡½æ•°å½“å‘ç”Ÿéæ­£å¸¸çš„æ§åˆ¶æµæ”¹å˜ï¼ˆä¸»è¦æ˜¯ä¿¡å· Signal å¤„ç†ï¼‰æ—¶è°ƒç”¨ContextChangeå‡½æ•°ã€‚
4. è¿›ç¨‹ä¸å¤šä»»åŠ¡ã€‚ä½¿ç”¨PIN_AddFiniFunctionå‡½æ•°åœ¨ç›®æ ‡ç¨‹åºå½»åº•ç»“æŸï¼ˆexitï¼‰æ—¶è°ƒç”¨Finiå‡½æ•°ã€‚Finiå‡½æ•°åˆä¼šæ¥ç€è°ƒç”¨SimEndå‡½æ•°æ‰§è¡ŒçœŸæ­£çš„ç»“æŸä»»åŠ¡ã€‚åŒæ—¶éœ€è¦å¤„ç†è¿›ç¨‹æ ‘çš„æ¨¡æ‹Ÿã€‚ä½¿ç”¨PIN_AddFollowChildProcessFunctionæŒ‡å®šFollowChildï¼ˆå‘Šè¯‰ Pinï¼Œå¦‚æœå½“å‰ç¨‹åºè°ƒç”¨äº† exec å¯åŠ¨æ–°ç¨‹åºï¼Œè¯·ç»§ç»­è·Ÿè¸ªæ–°ç¨‹åºï¼ŒæŠŠPinToolæ³¨å…¥è¿›å»ï¼‰ã€‚ç„¶åPIN_AddForkFunctionè®¾ç½®è°ƒç”¨BeforeForkï¼ˆèµ‹å€¼é™æ€å˜é‡forkedChildNodeä¸ºprocTreeNode->getNextChild()ï¼‰ï¼ŒAfterForkInParentï¼ˆforkedChildNodeè®¾ç½®ä¸ºnullptrï¼‰å’ŒAfterForkInChildï¼ˆè°ƒç”¨procTreeNode->notifyStart()ï¼Œè¾“å‡ºæ–°è¿›ç¨‹çš„ä¿¡æ¯ï¼Œå¹¶ä¸”åˆå§‹è¿™ä¸ªæ–°PINè¿›ç¨‹çš„fPtrsä¸ºjoinPtrsã€cidsä¸ºUNINITIALIZED_CIDï¼Œå¹¶ä¸”è®©å­è¿›ç¨‹ä¹Ÿå¼€å§‹æ‰§è¡ŒFFThreadï¼‰ã€‚ç„¶åä¸»è¿›ç¨‹çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹å¹¶æ‰§è¡ŒFFThreadå‡½æ•°ï¼Œç„¶åè‡ªå·±é€šè¿‡PIN_StartProgramå‡½æ•°ä¸å†è¿”å›ã€‚æ‰€ä»¥è¿™é‡Œå…¶å®æ¨¡æ‹Ÿå™¨ç¨‹åºæœ¬èº«æœ€ç»ˆè¿è¡Œçš„éƒ½æ˜¯FFThreadå‡½æ•°ï¼Œä¸ç®¡æ˜¯ä¸»è¿›ç¨‹è¿˜æ˜¯forkåçš„è¿›ç¨‹ï¼Œéƒ½éœ€è¦FFThreadå‡½æ•°è¿›è¡Œä»¿çœŸã€‚

### Trace

åŒºåˆ†ä¸¤ä¸ªæ—¶é—´ç‚¹ï¼š

1. æ’æ¡©æ—¶ (Instrumentation Time)ï¼šå³ Trace() å‡½æ•°æ‰§è¡Œçš„æ—¶å€™ã€‚è¿™æ˜¯ Pin åœ¨å³æ—¶ç¼–è¯‘ï¼ˆJITï¼‰ä»£ç ï¼Œå®ƒå†³å®šäº†â€œè¦æ’å…¥ä»€ä¹ˆä»£ç â€ã€‚

2. åˆ†æ/æ‰§è¡Œæ—¶ (Analysis/Execution Time)ï¼šå³ç›®æ ‡ç¨‹åºçœŸæ­£è¿è¡Œçš„æ—¶å€™ã€‚æ­¤æ—¶ï¼Œè¢«æ’å…¥çš„é‚£äº›å‡½æ•°ï¼ˆå¦‚ IndirectBasicBlockï¼‰æ‰ä¼šè¢«çœŸæ­£è°ƒç”¨ã€‚

#### 1. æ€»å…¥å£

å½“ Pin å‘ç°ä¸€æ®µæ–°çš„ä»£ç è½¨è¿¹ï¼ˆTraceï¼Œé€šå¸¸æ˜¯ä¸€ä¸²åŸºæœ¬å— Basic Blockï¼‰æ—¶è°ƒç”¨ã€‚å®ƒçš„ä»»åŠ¡æ˜¯éå†è¿™æ®µä»£ç ï¼Œæ’å…¥ zsim çš„å›è°ƒå‡½æ•°ã€‚

ä»£ç é¦–å…ˆéå† Trace ä¸­çš„æ¯ä¸€ä¸ªåŸºæœ¬å—ï¼ˆBBLï¼‰ã€‚å‰ææ¡ä»¶ï¼š å¦‚æœå½“å‰å¤„äºâ€œå¿«è¿›æ¨¡å¼â€(FastForward) ä¸”ä¸éœ€è¦é‡æ’æ¡©ï¼Œåˆ™è·³è¿‡æ­¤æ­¥ï¼ˆä¸ºäº†æ€§èƒ½ï¼‰ã€‚

- Decoder::decodeBbl(bbl, ...)ï¼š
  - å¹²ä»€ä¹ˆï¼šè¿™æ˜¯ä¸€ä¸ªé™æ€åˆ†æè¿‡ç¨‹ã€‚å®ƒåˆ†æè¿™ä¸ª BBL é‡Œæœ‰å¤šå°‘æŒ‡ä»¤ã€æœ‰å¤šå°‘å†…å­˜æ“ä½œã€æŒ‡ä»¤é—´çš„ä¾èµ–å…³ç³»ç­‰ã€‚
  - äº§å‡ºï¼šç”Ÿæˆä¸€ä¸ª BblInfo ç»“æ„ä½“ï¼Œé‡Œé¢åŒ…å«äº†æ¨¡æ‹Ÿè¿™ä¸ª BBL æ‰€éœ€çš„æ‰€æœ‰å…ƒæ•°æ®ï¼ˆæŒ‡ä»¤æ•°ã€å­—èŠ‚æ•°ç­‰ï¼‰ã€‚
- BBL_InsertCall(..., IndirectBasicBlock, ...)ï¼š
  - å¹²ä»€ä¹ˆï¼šåœ¨ BBL çš„å¼€å¤´æ’å…¥ä¸€ä¸ªè°ƒç”¨ã€‚
  - æ’å…¥äº†è°ï¼šIndirectBasicBlockã€‚
  - å‚æ•°ï¼šä¼ å…¥äº† BblInfo æŒ‡é’ˆã€‚
  - æ„ä¹‰ï¼šå½“ç¨‹åºè¿è¡Œåˆ°è¿™ä¸ªåŸºæœ¬å—æ—¶ï¼Œzsim ä¼šå…ˆè·å¾—æ§åˆ¶æƒï¼Œæ‹¿åˆ°è¿™ä¸ªå—çš„å…ƒæ•°æ®ï¼Œç„¶åç®—å‡ºè¿™ä¸ªå—æ¶ˆè€—äº†å¤šå°‘å‘¨æœŸï¼ˆCycleï¼‰ï¼Œæ¨è¿›æ¨¡æ‹Ÿæ—¶é—´ã€‚

#### 2. æŒ‡ä»¤ (Instruction) çº§æ’æ¡©

æ¥ç€ï¼Œä»£ç å†æ¬¡éå† BBLï¼Œå¹¶æ·±å…¥éå†å…¶ä¸­çš„æ¯ä¸€æ¡æŒ‡ä»¤ï¼ˆINSï¼‰ã€‚è°ƒç”¨ï¼šInstruction(ins)ã€‚èŒè´£ï¼šå†³å®šå¯¹å½“å‰è¿™æ¡å…·ä½“çš„æŒ‡ä»¤â€œåšç‚¹ä»€ä¹ˆâ€ã€‚

- å†…å­˜è®¿é—®æ’æ¡© (Memory Access)
  - åˆ¤æ–­ï¼šé€šè¿‡ INS_IsMemoryRead / INS_IsMemoryWrite æ£€æŸ¥æŒ‡ä»¤æ˜¯å¦è¯»å†™å†…å­˜ã€‚
  - æ’å…¥ï¼š
    - å¦‚æœæ˜¯è¯»ï¼šæ’å…¥ IndirectLoadSingleã€‚
    - å¦‚æœæ˜¯å†™ï¼šæ’å…¥ IndirectStoreSingleã€‚
  - å‚æ•°ï¼šä¼ å…¥ IARG_MEMORYREAD_EA (æœ‰æ•ˆåœ°å€)ã€‚
  - æ„ä¹‰ï¼šè¿™æ˜¯ Cache æ¨¡æ‹Ÿçš„åŸºç¡€ã€‚zsim éœ€è¦æ‹¦æˆªæ¯ä¸€æ¬¡å†…å­˜è®¿é—®çš„åœ°å€ï¼Œæ‰”ç»™ Cache å±‚æ¬¡ç»“æ„å»åˆ¤æ–­æ˜¯ Hit è¿˜æ˜¯ Missã€‚
- åˆ†æ”¯é¢„æµ‹æ’æ¡© (Branch Prediction)
  - åˆ¤æ–­ï¼šINS_Category(ins) == XED_CATEGORY_COND_BRï¼ˆæ¡ä»¶è·³è½¬ï¼‰ã€‚
  - æ’å…¥ï¼šIndirectRecordBranchã€‚
  - æ„ä¹‰ï¼šå°†åˆ†æ”¯çš„è·³è½¬æ–¹å‘ï¼ˆTaken/Not Takenï¼‰å’Œç›®æ ‡åœ°å€ä¼ ç»™ CPU æ¨¡å‹çš„åˆ†æ”¯é¢„æµ‹å™¨ (Branch Predictor)ï¼Œç”¨æ¥æ›´æ–°é¢„æµ‹å†å²å¹¶è®¡ç®—é¢„æµ‹å¤±è´¥çš„æƒ©ç½šã€‚

##### è™šæ‹ŸåŒ–ä¸é­”æ³•æŒ‡ä»¤ (Virtualization & Magic)

è¿™æ˜¯ zsim èƒ½å¤Ÿâ€œæ¬ºéª—â€ç›®æ ‡ç¨‹åºçš„å…³é”®ã€‚

- Magic Ops (xchg %rcx, %rcx)ï¼š
  - æ’å…¥ï¼šHandleMagicOpã€‚
  - åŠŸèƒ½ï¼šè¿™æ˜¯ä¸€ä¸ªâ€œåé—¨â€ã€‚è¢«æ¨¡æ‹Ÿçš„ç¨‹åºå¯ä»¥é€šè¿‡è¿™æ¡ç‰¹æ®Šçš„æ±‡ç¼–æŒ‡ä»¤å‘Šè¯‰ zsimï¼šâ€œå¼€å§‹æ„Ÿå…´è¶£åŒºåŸŸ(ROI)â€ã€â€œå¿ƒè·³â€ã€â€œæ³¨å†Œçº¿ç¨‹â€ç­‰ã€‚è¿™å®ç°äº† Guest å’Œ Host çš„é€šä¿¡ã€‚
- CPUID (FakeCPUIDPre/Post)ï¼š
  - æ’å…¥ï¼šåœ¨ CPUID æŒ‡ä»¤çš„å‰åæ’å…¥ã€‚
  - åŠŸèƒ½ï¼šCPUID æŒ‡ä»¤é€šå¸¸è¿”å›å®¿ä¸»æœºçš„ CPU ä¿¡æ¯ã€‚zsim å¿…é¡»æ‹¦æˆªå®ƒï¼Œç¯¡æ”¹å¯„å­˜å™¨ï¼ˆEAX, EBX ç­‰ï¼‰çš„å€¼ï¼Œè®©ç¨‹åºä»¥ä¸ºè‡ªå·±è¿è¡Œåœ¨ zsim é…ç½®çš„é‚£ä¸ª 64 æ ¸ CPU ä¸Šï¼Œè€Œä¸æ˜¯ä½ çš„ç¬”è®°æœ¬ç”µè„‘ä¸Šã€‚ä»£ç ä¸­å¯ä»¥çœ‹åˆ°å®ƒè®¡ç®— apicId å’Œ siblings çš„é€»è¾‘ã€‚
- RDTSC (FakeRDTSCPost)ï¼š
  - æ’å…¥ï¼šåœ¨ RDTSC æŒ‡ä»¤åæ’å…¥ã€‚
  - åŠŸèƒ½ï¼šRDTSC è¯»å–ç¡¬ä»¶çš„æ—¶é—´æˆ³è®¡æ•°å™¨ã€‚zsim å¿…é¡»æ‹¦æˆªå¹¶è¦†ç›–å®ƒçš„è¿”å›å€¼ï¼ˆEAX:EDXï¼‰ï¼Œå¡«å…¥ zinfo->globPhaseCyclesï¼ˆæ¨¡æ‹Ÿæ—¶é—´ï¼‰ã€‚å¦‚æœè¿™é‡Œä¸æ‹¦æˆªï¼Œç¨‹åºè¯»åˆ°çš„æ˜¯çœŸå®ä¸–ç•Œçš„é£å¿«æµé€çš„æ—¶é—´ï¼Œæ¨¡æ‹Ÿç»“æœå°±ä¼šå®Œå…¨é”™è¯¯ï¼ˆTime Leakageï¼‰ã€‚

#### 3. Indirect... ç³»åˆ—å‡½æ•°ä¸ fPtrsï¼šå¤šæ€çš„å®ç°

fPtrs (Function Pointers)ï¼šè¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªçº¿ç¨‹ (tid) å¯¹åº”ä¸€ä¸ª InstrFuncPtrs ç»“æ„ä½“ï¼Œé‡Œé¢å­˜ç€ loadPtr, storePtr, bblPtr ç­‰å‡½æ•°æŒ‡é’ˆã€‚

- å½“çº¿ç¨‹å¤„äº Detailed Simulation (NFF) æ¨¡å¼æ—¶ï¼ŒfPtrs[tid] æŒ‡å‘çœŸæ­£çš„æ¨¡æ‹Ÿå‡½æ•°ï¼ˆå¦‚ SimLoadï¼‰ã€‚
- å½“çº¿ç¨‹å¤„äº Fast Forward (FF) æ¨¡å¼æ—¶ï¼ŒfPtrs[tid] æŒ‡å‘ç©ºå‡½æ•°ï¼ˆNopLoadï¼‰ã€‚
- å½“çº¿ç¨‹å¤„äº Null/Blocked çŠ¶æ€æ—¶ï¼Œå®ƒæŒ‡å‘å¦ä¸€ç»„å‡½æ•°ã€‚

### FFThread

è¿™ä¸ªæœºåˆ¶çš„è®¾è®¡åˆè¡·æ˜¯ä¸ºäº†è§£å†³ Intel Pin åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¤„ç†ä¿¡å·ï¼ˆSignalï¼‰ä¸ç¨³å®šçš„é—®é¢˜ï¼Œå› æ­¤ä½œè€…é€‰æ‹©äº†ä¸€ä¸ªâ€œç¬¨åŠæ³•â€ï¼šç”¨ä¸€ä¸ªçº¿ç¨‹æ­»å¾ªç¯ç­‰å¾…å¤–éƒ¨è§¦å‘ã€‚

1. FFThread çš„æ ¸å¿ƒé€»è¾‘ï¼šæ— é™ç­‰å¾…å¾ªç¯
    - è§’è‰²ï¼šè¿™æ˜¯ä¸€ä¸ªâ€œå®ˆæŠ¤çº¿ç¨‹â€ï¼Œå®ƒä¸å‚ä¸æ¨¡æ‹Ÿï¼Œåªè´Ÿè´£ç›‘å¬å¼€å…³è¯·æ±‚ã€‚
    - å¯åŠ¨ï¼šåœ¨ main å‡½æ•°ä¸­é€šè¿‡ PIN_SpawnInternalThread å¯åŠ¨ã€‚
        1. åˆå§‹åŒ–é”ï¼šffToggleLocks æ˜¯é€šä¿¡çš„åª’ä»‹ã€‚çº¿ç¨‹å…ˆé”ä½å®ƒï¼Œç„¶åè¯•å›¾å†æ¬¡åŠ é”ï¼ˆè§ä¸‹æ–‡ï¼‰ï¼Œè¿™æ ·å®ƒå°±ä¼šé˜»å¡ã€‚å¤–éƒ¨è§¦å‘å™¨ï¼ˆä¾‹å¦‚å¦ä¸€ä¸ªå·¥å…· fftoggleï¼‰é€šè¿‡è§£é” (unlock) è¿™ä¸ª mutex æ¥â€œæ…â€ä¸€ä¸‹ zsimï¼Œå‘Šè¯‰å®ƒâ€œè¯¥åˆ‡æ¢æ¨¡å¼äº†â€ã€‚
        2. è¿›å…¥å¾ªç¯ç­‰å¾…è§¦å‘ã€‚`bool locked = futex_trylock_nospin_timeout(..., 5*BILLION);`ï¼Œçº¿ç¨‹åœ¨è¿™é‡Œé˜»å¡ã€‚å®ƒå°è¯•å»é”é‚£ä¸ªå·²ç»è¢«è‡ªå·±é”ä½çš„é”ï¼ˆæˆ–è€…ç­‰å¾…åˆ«äººè§£é”å®ƒï¼‰ã€‚è¶…æ—¶æœºåˆ¶ (5ç§’)ï¼šå®ƒæ¯ 5 ç§’é†’æ¥ä¸€æ¬¡ï¼Œä¸æ˜¯ä¸ºäº†åˆ‡æ¢ï¼Œè€Œæ˜¯æ£€æŸ¥ zinfo->terminationConditionMetï¼ˆæ¨¡æ‹Ÿæ˜¯å¦ç»“æŸäº†ï¼Ÿï¼‰ï¼Œä»¥ä¾¿ä¼˜é›…é€€å‡ºã€‚è¢«å”¤é†’ï¼šå¦‚æœ locked == trueï¼Œè¯´æ˜æœ‰äººåœ¨å¤–é¢è§£å¼€äº†è¿™æŠŠé”ã€‚è¿™æ„å‘³ç€æ”¶åˆ°äº†åˆ‡æ¢ä¿¡å·ã€‚
        3. å¤„ç†åˆ‡æ¢è¯·æ±‚ã€‚æ‹¿åˆ°å…¨å±€é” zinfo->ffLock ä¿æŠ¤çŠ¶æ€ã€‚åˆ¤æ–­å½“å‰çŠ¶æ€ï¼šæƒ…å†µ Aï¼šæ­£åœ¨å¿«è¿› (FF) -> åˆ‡å›è¯¦ç»†æ¨¡æ‹Ÿã€‚æƒ…å†µ Bï¼šæ­£åœ¨è¯¦ç»†æ¨¡æ‹Ÿ (NFF) -> åˆ‡å…¥å¿«è¿›ã€‚
2. é€€å‡ºå¿«è¿› (ExitFastForward) - "ç®€å•æ¨¡å¼"
    - å¦‚æœå½“å‰æ˜¯å¿«è¿›æ¨¡å¼ï¼Œåˆ‡æ¢å›è¯¦ç»†æ¨¡æ‹Ÿæ˜¯æ¯”è¾ƒå®‰å…¨çš„ï¼Œå¯ä»¥ç«‹å³æ‰§è¡Œã€‚
    - è°ƒç”¨ ExitFastForward()
        1. VirtCaptureClocks(true)ï¼šå› ä¸ºå¿«è¿›æ—¶ä½¿ç”¨çš„æ˜¯â€œå‡â€æ—¶é—´ï¼Œåˆ‡å›è¯¦ç»†æ¨¡æ‹Ÿå‰ï¼Œå¿…é¡»æŠŠè™šæ‹Ÿæ—¶é—´ï¼ˆTSC/Cycleï¼‰åŒæ­¥å¯¹é½ï¼Œç¡®ä¿æ¨¡æ‹Ÿçš„æ—¶é—´è¿ç»­æ€§ã€‚
        2. procTreeNode->exitFastForward()ï¼šä¿®æ”¹å†…å­˜ä¸­çš„çŠ¶æ€æ ‡å¿— inFastForward = falseã€‚åŸå­æ›´æ–°å…¨å±€è®¡æ•°å™¨ã€‚
        3. __sync_synchronize()ï¼šå†…å­˜å±éšœï¼Œç¡®ä¿æ ‡å¿—ä½å˜åŒ–å¯¹æ‰€æœ‰çº¿ç¨‹å¯è§ã€‚
        4. PIN_RemoveInstrumentation() (å¦‚æœé…ç½®äº† ffReinstrument)ï¼š è¿™ä¼šå‘Šè¯‰ Pinï¼šâ€œä¸¢å¼ƒå½“å‰æ‰€æœ‰çš„ JIT ä»£ç ç¼“å­˜â€ã€‚åæœï¼šPin è¢«è¿«é‡æ–°æ’æ¡©ã€‚æ­¤æ—¶ inFastForward å˜æˆäº† falseï¼Œæ‰€ä»¥å†æ¬¡è°ƒç”¨ Trace() å‡½æ•°æ—¶ï¼Œä¼šæ’å…¥ IndirectBasicBlock å’Œ Load/Store çš„å›è°ƒï¼Œä»è€Œå¼€å¯è¯¦ç»†æ¨¡æ‹Ÿã€‚
3. è¿›å…¥å¿«è¿› (EnterFastForward) - "å›°éš¾æ¨¡å¼"
    - å¦‚æœå½“å‰æ­£åœ¨è¿›è¡Œè¯¦ç»†æ¨¡æ‹Ÿï¼Œæˆ‘ä»¬ä¸èƒ½ç«‹å³åˆ‡æ¢ã€‚å› ä¸ºæ¨¡æ‹Ÿå™¨æ˜¯ä»¥ Phase (é˜¶æ®µ) ä¸ºå•ä½è¿è¡Œçš„ï¼ˆä¾‹å¦‚æ¯ 10000 ä¸ªå‘¨æœŸåŒæ­¥ä¸€æ¬¡ï¼‰ã€‚å¦‚æœåœ¨é˜¶æ®µä¸­é—´çªç„¶åˆ‡æ–­è¯¦ç»†æ¨¡æ‹Ÿï¼Œä¼šå¯¼è‡´ä¸åŒæ ¸å¿ƒçš„æ—¶é—´ä¸åŒæ­¥ã€‚å› æ­¤ï¼ŒFFThread å¿…é¡»ç­‰å¾…å½“å‰ Phase ç»“æŸã€‚
    - è°ƒç”¨é“¾ä¸æ¡æ‰‹æµç¨‹ï¼š
        1. `zinfo->eventQueue->insert(syncEv);`,FFThread å¾€å…¨å±€äº‹ä»¶é˜Ÿåˆ—é‡Œæ‰”äº†ä¸€ä¸ª SyncEventã€‚è¿™ä¸ªäº‹ä»¶ä¼šåœ¨ä¸‹ä¸€ä¸ª Phase ç»“æŸæ—¶è¢«ä¸»æ¨¡æ‹Ÿçº¿ç¨‹å¤„ç†ã€‚
        2. `syncEv->wait();`ï¼Œé‡Šæ”¾é”å¹¶ç­‰å¾… (wait)ã€‚
        3. ä¸»æ¨¡æ‹Ÿçº¿ç¨‹ (Main Simulation Thread) çš„å·¥ä½œï¼ˆæ­¤æ—¶ FFThread åœ¨ç¡è§‰ï¼‰:
            - å®ƒè·‘å®Œå½“å‰çš„ Phaseã€‚
            - å¤„ç†äº‹ä»¶é˜Ÿåˆ—ï¼Œå–å‡º syncEvã€‚
            - è°ƒç”¨ syncEv->callback()ã€‚callback å†…éƒ¨ï¼šå”¤é†’ FFThreadï¼Œç„¶åè‡ªå·±é˜»å¡ï¼ˆç­‰å¾… FFThread å®Œæˆåˆ‡æ¢å·¥ä½œï¼‰ã€‚
        4. FFThread é†’æ¥ï¼Œé‡æ–°è·å–é”ï¼Œè°ƒç”¨ EnterFastForward()ã€‚EnterFastForward çš„å­è¿‡ç¨‹ï¼š
            1. `procTreeNode->enterFastForward()`ï¼šè®¾ç½®æ ‡å¿—ä½ inFastForward = trueã€‚
            2. `PIN_RemoveInstrumentation()`ï¼šå…³é”®ï¼ å†æ¬¡æ¸…ç©º Pin çš„ä»£ç ç¼“å­˜ã€‚
        5. `syncEv->signal();`ï¼Œé€šçŸ¥ä¸»çº¿ç¨‹ç»§ç»­ï¼Œä¸»æ¨¡æ‹Ÿçº¿ç¨‹ä» callback() ä¸­è¿”å›ï¼Œç»§ç»­æ‰§è¡Œï¼ˆæ­¤æ—¶å·²è¿›å…¥å¿«è¿›æ¨¡å¼ï¼‰ã€‚

### ThreadStart

å½“ç›®æ ‡ç¨‹åºè°ƒç”¨ pthread_create æˆ– clone æ—¶ï¼ŒPin æ•è·åˆ°è¿™ä¸€äº‹ä»¶ï¼Œå¹¶è°ƒç”¨ ThreadStartã€‚è°ƒç”¨æ—¶æœºï¼šç›®æ ‡çº¿ç¨‹åˆšåˆšè¢«æ“ä½œç³»ç»Ÿåˆ›å»ºï¼Œä½†è¿˜æ²¡æœ‰å¼€å§‹æ‰§è¡Œä»»ä½•å…·ä½“çš„åº”ç”¨ä»£ç ã€‚

1. `if (procTreeNode->isInPause()) { ... }`ï¼šå¦‚æœé…ç½®è¦æ±‚ç¨‹åºå¯åŠ¨æ—¶å…ˆâ€œæš‚åœâ€ï¼ˆç­‰å¾…å¤–éƒ¨ä¿¡å·ï¼Œæ¯”å¦‚è°ƒè¯•å™¨æˆ–å¤šè¿›ç¨‹åŒæ­¥ï¼‰ï¼Œè¿™é‡Œä¼šé˜»å¡çº¿ç¨‹ã€‚åˆ©ç”¨ futex_lock é”åŒä¸€ä¸ªå˜é‡ä¸¤æ¬¡ã€‚ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ï¼Œç¬¬äºŒæ¬¡é˜»å¡ã€‚ç›´åˆ°å¤–éƒ¨å·¥å…·è§£å¼€è¿™ä¸ªé”ï¼Œçº¿ç¨‹æ‰ä¼šç»§ç»­ã€‚
2. zsim æ ¹æ®å½“å‰çš„æ¨¡æ‹Ÿæ¨¡å¼ï¼Œå†³å®šç»™è¿™ä¸ªæ–°çº¿ç¨‹åˆ†é…ä»€ä¹ˆæ ·çš„â€œå‡½æ•°æŒ‡é’ˆè¡¨â€ (fPtrs)ï¼š
    - å¿«è¿›æ¨¡å¼ (isInFastForward)ï¼šç»™çº¿ç¨‹è£…é…â€œå¿«è¿›ä¸“ç”¨â€çš„æ’æ¡©å‡½æ•°ï¼ˆåªè®¡æ•°ï¼Œä¸æ¨¡æ‹Ÿ Cache/Coreï¼‰ã€‚
    - å½±å­/æ³¨å†Œæ¨¡å¼ (registerThreads)ï¼šç»™çº¿ç¨‹è£…é…â€œç©ºæ“ä½œï¼ˆNOPï¼‰â€æ’æ¡©ã€‚å¦‚æœä½ åªå…³å¿ƒç¨‹åºçš„æŸä¸ªç‰¹å®šåŒºåŸŸï¼ˆROIï¼‰ã€‚çº¿ç¨‹è™½ç„¶å¯åŠ¨äº†ï¼Œä½†åœ¨ç¢°åˆ° Magic Op æ˜¾å¼â€œæ³¨å†Œâ€è‡ªå·±ä¹‹å‰ï¼Œzsim å½“å®ƒä¸å­˜åœ¨ï¼Œä¸æ¨¡æ‹Ÿå®ƒã€‚
    - æ­£å¸¸è¯¦ç»†æ¨¡æ‹Ÿ (Normal Start)ï¼šè°ƒç”¨ SimThreadStart(tid)

### SimThreadStart

çœŸæ­£çš„åˆå§‹åŒ–é€»è¾‘ï¼š

1. `zinfo->sched->start(...)`ï¼šè°ƒç”¨ Scheduler ç±»ï¼Œåœ¨ gidMap ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ ThreadInfo å¯¹è±¡ã€‚æ­¤æ—¶çº¿ç¨‹çŠ¶æ€è¢«è®¾ä¸º STARTEDï¼Œä½†è¿˜æ²¡æœ‰åˆ†é…ç‰©ç†æ ¸å¿ƒ (cid)ã€‚
2. `activeThreads[tid] = true;`ï¼šæ›´æ–°æœ¬åœ°çš„æ´»è·ƒä½å›¾ã€‚
3. `fPtrs[tid] = joinPtrs;`ï¼šæ–°çº¿ç¨‹ä¸èƒ½ç›´æ¥å†²è¿›æ¨¡æ‹Ÿå¾ªç¯ï¼Œå› ä¸ºå®ƒé”™è¿‡äº†å½“å‰ Phase çš„åŒæ­¥ç‚¹ã€‚joinPtrs æ˜¯ä¸€ç»„ç‰¹æ®Šçš„å‡½æ•°æŒ‡é’ˆï¼Œå®ƒä»¬ä¼šè®©çº¿ç¨‹åœ¨æ‰§è¡Œç¬¬ä¸€æ¡æŒ‡ä»¤æ—¶ï¼Œå¼ºåˆ¶è°ƒç”¨ Scheduler::join()ã€‚è¿™æ ·ï¼Œæ–°çº¿ç¨‹ä¼šå…ˆå»æ’é˜Ÿï¼Œé¢†å–ä¸€ä¸ª Core ID (cid)ï¼Œç­‰åˆ°ä¸‹ä¸€ä¸ª Phase å¼€å§‹æ—¶ï¼Œæ‰æ­£å¼åŠ å…¥æ¨¡æ‹Ÿå¤§å†›ã€‚
4. `clearCid(tid);`ï¼šç¡®ä¿ cids[tid] è¢«åˆå§‹åŒ–ä¸ºæ— æ•ˆå€¼ï¼Œç­‰å¾… Scheduler åˆ†é…ã€‚

### ThreadFini

å½“ç›®æ ‡çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼ˆpthread_exit æˆ–ä»çº¿ç¨‹å‡½æ•°è¿”å›ï¼‰æ—¶ï¼ŒPin è°ƒç”¨æ­¤å‡½æ•°ã€‚è°ƒç”¨æ—¶æœºï¼šçº¿ç¨‹å³å°†è¢«é”€æ¯ï¼Œæ­¤æ—¶å®ƒè¿˜å¯ä»¥æ‰§è¡Œä¸€äº›æ¸…ç†ä»£ç ã€‚

1. `if (fPtrs[tid].type == FPTR_NOP) { return; }`ï¼šæ£€æŸ¥è¿™ä¸ªçº¿ç¨‹æ˜¯ä¸æ˜¯ä¸€ä¸ªâ€œå½±å­çº¿ç¨‹â€ï¼ˆä»æœªè¢«æ¿€æ´»è¿‡ï¼‰ã€‚ç›´æ¥å¿½ç•¥ï¼Œå› ä¸ºå®ƒä»æœªåœ¨ Scheduler é‡Œæ³¨å†Œè¿‡ï¼Œä¸éœ€è¦æ³¨é”€ã€‚å¦åˆ™è°ƒç”¨ SimThreadFini(tid);

### SimThreadFini

1. `zinfo->sched->finish(procIdx, tid);`ï¼šæ³¨é”€è°ƒåº¦å™¨ã€‚
2. `activeThreads[tid] = false;`ã€`cids[tid] = UNINITIALIZED_CID;`ï¼šæ›´æ–°çŠ¶æ€ï¼Œé˜²æ­¢åç»­æœ‰é‡æŒ‡é’ˆé€šè¿‡ tid è®¿é—®åˆ°é”™è¯¯çš„æ ¸å¿ƒæ•°æ®ã€‚

### Fini

å½“è¢«æ¨¡æ‹Ÿçš„ç›®æ ‡ç¨‹åºï¼ˆGuest Applicationï¼‰æ‰§è¡Œå®Œæ¯•ï¼Œæˆ–è€… zsim å†³å®šå¼ºåˆ¶ç»“æŸæ¨¡æ‹Ÿæ—¶ï¼Œè¿™ä¸€å¥—æµç¨‹ä¼šè¢«è§¦å‘ã€‚å®ƒä»¬çš„ä»»åŠ¡æ˜¯ï¼šç¡®ä¿å¤šçº¿ç¨‹/å¤šè¿›ç¨‹ç¯å¢ƒä¸‹çš„å®‰å…¨é€€å‡ºï¼Œå¹¶å®Œæ•´åœ°ä¿å­˜ç»Ÿè®¡æ•°æ® (zsim.out)ã€‚

Fini(int code, VOID * v)ä»…ä»…æ˜¯ Pin çš„å›è°ƒå…¥å£ã€‚

### SimEnd

1. `if (__sync_bool_compare_and_swap(&perProcessEndFlag, 0, 1) == false)`: ä¸€ä¸ªè¿›ç¨‹å¯èƒ½æœ‰å¤šä¸ªçº¿ç¨‹ã€‚å½“è¿›ç¨‹å´©æºƒæˆ–è°ƒç”¨ exit_group æ—¶ï¼ŒPin å¯èƒ½ä¼šè®©å¤šä¸ªçº¿ç¨‹åŒæ—¶è§¦å‘ Fini / SimEndã€‚éœ€è¦ç¡®ä¿æ¯ä¸ªè¿›ç¨‹åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œæ¸…ç†é€»è¾‘ã€‚
2. `bool lastToFinish = procTreeNode->notifyEnd();`ï¼šå‘Šè¯‰å…¨å±€å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰è¿™ä¸ªè¿›ç¨‹å·²ç»ç»“æŸäº†ã€‚åŸå­é€’å‡ zinfo->globalActiveProcsï¼ˆå…¨å±€æ´»è·ƒè¿›ç¨‹æ•°ï¼‰ã€‚è¿”å›å¸ƒå°”å€¼ï¼šå¦‚æœå‡å®Œä¹‹åå˜æˆäº† 0ï¼Œè¯´æ˜æˆ‘æ˜¯å…¨ç³»ç»Ÿæœ€åä¸€ä¸ªç»“æŸçš„è¿›ç¨‹ã€‚
3. Process 0 æœ€ç»ˆå¤„ç†ã€‚åœ¨ zsim çš„å¤šè¿›ç¨‹æ¨¡å‹ä¸­ï¼Œè¿›ç¨‹ 0 (Process 0) è¢«æŒ‡å®šä¸ºâ€œç®¡å®¶â€ã€‚å…¶ä»–è¿›ç¨‹ï¼ˆProcess 1, 2...ï¼‰ç»“æŸæ—¶åªç®¡è‡ªå·±æ­»æ‰ï¼Œä½† Process 0 å¿…é¡»ç•™åˆ°æœ€åæ‰“æ‰«æˆ˜åœºã€‚
    1. `while (zinfo->globalActiveProcs) usleep(100*1000);`ï¼šç­‰å¾…å…¶ä»–è¿›ç¨‹ã€‚
    2. `for (StatsBackend* backend : ...) backend->dump(false);`ï¼šdumpç»Ÿè®¡æ•°æ®ã€‚
    3. `zinfo->sched->notifyTermination()`ï¼šå‘Šè¯‰è°ƒåº¦å™¨é‡Œçš„ Watchdog çº¿ç¨‹ï¼Œä¸ç”¨å†æŸ¥æ­»é”äº†ï¼Œä¸€åˆ‡è¦ç»“æŸäº†ã€‚

### SyscallEnter

å½“ç›®æ ‡ç¨‹åºæ‰§è¡Œ syscall æŒ‡ä»¤ä½†å°šæœªè¿›å…¥å†…æ ¸æ—¶ï¼ŒPin è°ƒç”¨æ­¤å‡½æ•°ã€‚

1. è§¦å‘è™šæ‹ŸåŒ–è¡¥ä¸ (Patching)ï¼šæ£€æŸ¥æ­¤ç³»ç»Ÿè°ƒç”¨æ˜¯å¦éœ€è¦è¢«æ‹¦æˆªæˆ–ä¿®æ”¹ã€‚
2. è°ƒåº¦å™¨é€šçŸ¥ (Scheduling)ï¼šå‘Šè¯‰è°ƒåº¦å™¨â€œæˆ‘è¦ç¦»å¼€ç”¨æˆ·æ€å»å†…æ ¸åŠäº‹äº†â€ï¼Œå¹¶äº¤è¿˜ CPU (leave)ã€‚

å­è¿‡ç¨‹ï¼š

1. `bool isNopThread = ...;`ã€`bool isRetryThread = ...;`ï¼šæ£€æŸ¥å½“å‰çº¿ç¨‹æ˜¯å¦æ˜¯â€œå½±å­çº¿ç¨‹â€ï¼ˆä¸æ¨¡æ‹Ÿï¼‰æˆ–è€…æ˜¯æ­£åœ¨â€œé‡è¯•â€æŸä¸ªè¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨ã€‚
2. `VirtSyscallEnter(tid, ctxt, std, ...);`ï¼špatché€»è¾‘çš„æ ¸å¿ƒå…¥å£
    - ä»£ç ä¸­åŒ…å«äº†é’ˆå¯¹ SYS_arch_prctl (CET protection) å’Œ SYS_clone3 çš„ç‰¹æ®Šå¤„ç†ã€‚ä¸ºäº†é˜²æ­¢ Pin å´©æºƒæˆ–å…¼å®¹ glibcï¼Œzsim ä¼šæ‰‹åŠ¨è·³è¿‡è¿™äº›æŒ‡ä»¤å¹¶è¿”å›é”™è¯¯ç ï¼Œå‡è£…å†…æ ¸ä¸æ”¯æŒè¿™äº›ç‰¹æ€§ã€‚
    - `postPatchFunctions[tid] = prePatchFunctions[syscall](...);`ï¼šæŸ¥è¡¨åˆ†å‘ï¼Œå®ƒä½¿ç”¨ç³»ç»Ÿè°ƒç”¨å· (syscall) ä½œä¸ºç´¢å¼•ï¼Œåœ¨ prePatchFunctions è¡¨ï¼ˆæˆ‘ä»¬åœ¨ VirtInit ä¸­è§è¿‡çš„ï¼‰ä¸­æŸ¥æ‰¾å¯¹åº”çš„å¤„ç†å‡½æ•°ã€‚
3. `if (fPtrs[tid].type != FPTR_JOIN && !zinfo->blockingSyscalls) { ... }`ï¼šå¦‚æœè¿™ä¸æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ Join çº¿ç¨‹ï¼Œä¸”é…ç½®ä¸å…è®¸é˜»å¡å¼ç³»ç»Ÿè°ƒç”¨ï¼ˆé»˜è®¤æƒ…å†µï¼‰ï¼š
    - äº¤è¿˜ CPU (syscallLeave)ï¼šè¿™å‘Šè¯‰è°ƒåº¦å™¨ï¼šï¼ˆçº¿ç¨‹ tidï¼‰æ­£åœ¨ç¦»å¼€ç”¨æˆ·æ€ã€‚æˆ‘ç°åœ¨å ç”¨çš„ç‰©ç†æ ¸å¿ƒ cid å¿…é¡»è¢«é‡Šæ”¾ï¼Œä»¥ä¾¿å…¶ä»–çº¿ç¨‹ä½¿ç”¨ã€‚clearCid(tid)ï¼šæ¸…é™¤æœ¬åœ°çš„æ ¸å¿ƒæ˜ å°„ã€‚
    - `fPtrs[tid] = joinPtrs;`ï¼šè®¾ç½®å½’æ¥åçš„è¡Œä¸º (joinPtrs)ï¼Œè¿™æ„å‘³ç€ï¼Œå½“ç³»ç»Ÿè°ƒç”¨è¿”å›å¹¶æ‰§è¡Œä¸‹ä¸€æ¡ç”¨æˆ·æ€æŒ‡ä»¤æ—¶ï¼Œè¯¥çº¿ç¨‹ä¸ä¼šç›´æ¥æ‰§è¡Œï¼Œè€Œæ˜¯ä¼šè°ƒç”¨ joinPtrs æŒ‡å‘çš„å‡½æ•°ï¼Œè¢«è¿«å»è°ƒåº¦å™¨é‚£é‡Œæ’é˜Ÿé‡æ–°ç”³è¯·æ ¸å¿ƒ (join)ã€‚

### SyscallExit

å½“ç³»ç»Ÿè°ƒç”¨å®Œæˆï¼Œå†…æ ¸å³å°†è¿”å›ç”¨æˆ·æ€æ—¶ï¼ŒPin è°ƒç”¨æ­¤å‡½æ•°ã€‚è§¦å‘è™šæ‹ŸåŒ–åå¤„ç† (Post-Patching)ï¼šå¤„ç†è¿”å›å€¼ï¼Œå†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨ã€‚æ¢å¤çŠ¶æ€ï¼šå†³å®šçº¿ç¨‹æ¥ä¸‹æ¥æ˜¯ç”¨ joinPtrs æ’é˜Ÿï¼Œè¿˜æ˜¯æ¢å¤æ­£å¸¸æ‰§è¡Œï¼Œäº¦æˆ–æ˜¯è¿›å…¥å¿«è¿›æ¨¡å¼ã€‚

å­è¿‡ç¨‹ï¼š

1. `PostPatchAction ppa = VirtSyscallExit(tid, ctxt, std);`ï¼šå®ƒç›´æ¥è°ƒç”¨ä¹‹å‰ä¿å­˜çš„ `postPatchFunctions[tid](...)`ã€‚ä¾‹å¦‚ï¼Œå¯¹äº SYS_futexï¼Œå®ƒçš„ Post-Patch å‡½æ•°å¯èƒ½ä¼šæ£€æŸ¥è¿”å›å€¼ã€‚å¦‚æœ futex å†³å®šé˜»å¡çº¿ç¨‹ï¼ŒPost-Patch å‡½æ•°ä¼šå‘Šè¯‰è°ƒåº¦å™¨â€œè¿™ä¸ªçº¿ç¨‹ç¡ç€äº†â€ã€‚è¿”å›å€¼ ppaï¼šè¿™æ˜¯ä¸€ä¸ªåŠ¨ä½œæŒ‡ä»¤ï¼ˆActionï¼‰ï¼Œå‘Šè¯‰ SyscallExit ä¸‹ä¸€æ­¥è¯¥æ€ä¹ˆåšã€‚
2. ä¸‹ä¸€æ­¥ï¼š
    - PPA_USE_JOIN_PTRSï¼šæ„å‘³ç€ç³»ç»Ÿè°ƒç”¨æ­£å¸¸ç»“æŸã€‚è®¾ç½® fPtrs[tid] = joinPtrsã€‚çº¿ç¨‹å›åˆ°ç”¨æˆ·æ€çš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯å»è°ƒåº¦å™¨æ’é˜Ÿ (join)ã€‚ç‰¹ä¾‹ï¼šå¦‚æœ blockingSyscalls ä¸ºçœŸï¼ˆå°‘è§é…ç½®ï¼‰ï¼Œåˆ™ç›´æ¥æ¢å¤ GetFuncPtrs()ï¼Œä¸æ’é˜Ÿã€‚
    - PPA_USE_RETRY_PTRSï¼šæ„å‘³ç€ç³»ç»Ÿè°ƒç”¨è¢«ä¿¡å·ä¸­æ–­ï¼ˆEINTRï¼‰ï¼Œéœ€è¦é‡è¯•ã€‚è®¾ç½® fPtrs[tid] = retryPtrsã€‚
3. `if (fPtrs[tid].type == FPTR_JOIN && procTreeNode->isInFastForward()) { ... }`ï¼šFast-forwardingæ£€æŸ¥ã€‚å¦‚æœçº¿ç¨‹åœ¨ç³»ç»Ÿè°ƒç”¨æœŸé—´ï¼Œæ¨¡æ‹Ÿå™¨åˆ‡æ¢åˆ°äº†å¿«è¿›æ¨¡å¼ (Fast Forward)ã€‚é‚£ä¹ˆçº¿ç¨‹å°±ä¸åº”è¯¥å†å» joinï¼ˆæ’é˜Ÿç­‰å¾…æ¨¡æ‹Ÿæ ¸å¿ƒï¼‰äº†ï¼Œå› ä¸ºå¿«è¿›æ¨¡å¼ä¸‹ä¸éœ€è¦æ ¸å¿ƒã€‚
    - `SimThreadFini(tid)`ï¼šåœ¨ Scheduler é‡Œæ³¨é”€ï¼ˆå› ä¸ºå¿«è¿›æ¨¡å¼ä¸éœ€è¦ Scheduler ç®¡ç†ï¼‰ã€‚
    - `fPtrs[tid] = GetFFPtrs()`ï¼šç›´æ¥åˆ‡æ¢åˆ°å¿«è¿›æ’æ¡©å‡½æ•°ã€‚
4. å¦‚æœ `zinfo->terminationConditionMet` ä¸ºçœŸï¼ˆä¾‹å¦‚æŸä¸ªè¿›ç¨‹è°ƒç”¨äº† exit_groupï¼‰ï¼Œåˆ™è°ƒç”¨ SimEnd() ç»“æŸæ•´ä¸ªæ¨¡æ‹Ÿã€‚

### ContextChange

åœ¨æ­£å¸¸çš„æ¨¡æ‹Ÿæµç¨‹ä¸­ï¼Œç¨‹åºæŒ‰ç…§â€œåŸºæœ¬å— -> ç³»ç»Ÿè°ƒç”¨ -> åŸºæœ¬å—â€çš„é¡ºåºæ‰§è¡Œã€‚ä½†æ˜¯ï¼Œä¿¡å·ï¼ˆSignalsï¼‰çš„å­˜åœ¨æ‰“ç ´äº†è¿™ç§é¡ºåºã€‚å½“æ“ä½œç³»ç»Ÿå‘è¿›ç¨‹å‘é€ä¿¡å·ï¼ˆæ¯”å¦‚ SIGSEGV æ®µé”™è¯¯ï¼Œæˆ–è€… SIGINT ä¸­æ–­ï¼‰æ—¶ï¼Œç¨‹åºçš„æ§åˆ¶æµä¼šçªç„¶ä»å½“å‰ä½ç½®â€œç¬ç§»â€åˆ°ä¿¡å·å¤„ç†å‡½æ•°ï¼Œæˆ–è€…ç›´æ¥è¢«ç»ˆæ­¢ã€‚

ContextChange å°±æ˜¯ Intel Pin æä¾›çš„ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œç”¨æ¥é€šçŸ¥ zsim å‘ç”Ÿäº†éæ­£å¸¸çš„ä¸Šä¸‹æ–‡è·³è½¬ï¼ˆä¸æ˜¯æ™®é€šçš„å‡½æ•°è°ƒç”¨æˆ–è·³è½¬ï¼‰ã€‚

```c++
warn("[%d] ContextChange, reason %s, inSyscall %d", tid, reasonStr, inSyscall[tid]);
if (inSyscall[tid]) {
    SyscallExit(tid, to, SYSCALL_STANDARD_IA32E_LINUX, nullptr);
}
```

zsim åœ¨ SyscallEnter æ—¶ä¼šå°† inSyscall[tid] è®¾ä¸º trueã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼ŒSyscallExit ä¼šå°†å…¶è®¾å› falseã€‚å¦‚æœç³»ç»Ÿè°ƒç”¨è¢«ä¿¡å·æ‰“æ–­ï¼ˆä¾‹å¦‚ EINTRï¼‰ï¼ŒPin å¯èƒ½ä¸ä¼šè§¦å‘æ ‡å‡†çš„ SyscallExit å›è°ƒï¼Œè€Œæ˜¯ç›´æ¥è§¦å‘ ContextChange è·³è½¬åˆ°ä¿¡å·å¤„ç†å‡½æ•°ã€‚å¦‚æœä¸å¤„ç†ï¼ŒinSyscall[tid] ä¼šä¸€ç›´ä¿ç•™ä¸º trueã€‚ç­‰ä¿¡å·å¤„ç†å®Œå›åˆ°ä¸»ç¨‹åºï¼Œä¸‹ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œzsim ä¼šæ–­è¨€å¤±è´¥ï¼ˆassert falseï¼‰æˆ–è€…é€»è¾‘é”™ä¹±ã€‚åœ¨è¿™é‡Œå¼ºåˆ¶æ‰‹åŠ¨è°ƒç”¨ SyscallExitã€‚è¿™ç›¸å½“äºå¸® zsim â€œæ‰“è¡¥ä¸â€ï¼Œå¼ºè¡Œç»“æŸä¸Šä¸€ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ¨¡æ‹ŸçŠ¶æ€ï¼Œç¡®ä¿çŠ¶æ€æœºå¤ä½ã€‚

```c++
if (reason == CONTEXT_CHANGE_REASON_FATALSIGNAL) {
    info("[%d] Fatal signal caught, finishing", tid);
    zinfo->sched->queueProcessCleanup(procIdx, getpid());
    SimEnd();
}
```

å¦‚æœå‘ç”Ÿäº†æ®µé”™è¯¯ï¼ŒqueueProcessCleanupï¼šé€šçŸ¥è°ƒåº¦å™¨æ¸…ç†è¿™ä¸ªè¿›ç¨‹çš„é—ä½“ï¼ˆé‡Šæ”¾æ ¸å¿ƒã€ç§»é™¤çº¿ç¨‹ç»“æ„ï¼‰ã€‚SimEnd()ï¼šè¿™éå¸¸é‡è¦ã€‚å³ä½¿ç¨‹åºå´©æºƒäº†ï¼Œzsim ä¹Ÿå¸Œæœ›èƒ½å¤ŸæŠŠå·²ç»æ”¶é›†åˆ°çš„ç»Ÿè®¡æ•°æ®ï¼ˆzsim.outï¼‰å†™ç›˜ä¿å­˜ï¼Œè€Œä¸æ˜¯ç›´æ¥éšç¨‹åºä¸€èµ·æ¶ˆå¤±ã€‚è¿™è®©ç”¨æˆ·èƒ½çœ‹åˆ°â€œå´©æºƒå‰åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆâ€ã€‚

### PinCmd

å®ƒçš„æ ¸å¿ƒä»»åŠ¡æ˜¯å°†ç”¨æˆ·åœ¨é…ç½®æ–‡ä»¶ä¸­ç®€å•çš„å‘½ä»¤ï¼ˆä¾‹å¦‚ ls -lï¼‰ï¼Œè½¬æ¢æˆå¤æ‚çš„ Intel Pin å¯åŠ¨å‘½ä»¤ï¼ˆä¾‹å¦‚ /opt/pin/pin -t /path/to/libzsim.so -config zsim.cfg ... -- ls -lï¼‰ï¼Œå¹¶å¤„ç†æå…¶ç¹ççš„ç¯å¢ƒå˜é‡è®¾ç½®ã€‚

PinCmd åœ¨ä¸¤ä¸ªæˆªç„¶ä¸åŒçš„åœºæ™¯ä¸‹è¢«ä½¿ç”¨ï¼Œè°ƒç”¨é“¾è·¯ç•¥æœ‰ä¸åŒï¼š

1. Harness å¯åŠ¨æ—¶ï¼šåœ¨ zsim_harness ä¸­ï¼Œç”¨äºé€šè¿‡ fork + execvp å¯åŠ¨åˆå§‹çš„æ¨¡æ‹Ÿè¿›ç¨‹ã€‚
2. æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­ï¼šåœ¨ zsim.cpp (PinTool) ä¸­ï¼Œå½“è¢«æ¨¡æ‹Ÿç¨‹åºè°ƒç”¨ exec() æ—¶ï¼Œç”¨äºå‘Šè¯‰ Pin å¦‚ä½•æ¥ç®¡æ–°çš„å­è¿›ç¨‹ã€‚

### ContentionSim

ContentionSim æ˜¯ zsim ä¸­è´Ÿè´£æ¨¡æ‹Ÿéæ ¸å¿ƒç»„ä»¶ï¼ˆå¦‚ç¼“å­˜ã€å†…å­˜ã€äº’è¿ï¼‰æ—¶åºç«äº‰å’Œå»¶è¿Ÿçš„æ ¸å¿ƒå¼•æ“ã€‚å®ƒä¸åŸºäº Pin çš„åŠŸèƒ½æ¨¡æ‹Ÿï¼ˆFunctional Simulationï¼‰å’Œ CPU æ ¸å¿ƒçš„æ—¶åºæ¨¡æ‹Ÿï¼ˆTiming Simulationï¼‰æ˜¯å¹¶è¡Œä¸”è§£è€¦çš„ã€‚

zsim é‡‡ç”¨äº†ä¸€ç§Bound-Weave æ¨¡å‹ï¼š

- Bound Phase (Core Timing): æ¯ä¸ª CPU æ ¸å¿ƒç‹¬ç«‹è¿è¡Œï¼Œç”ŸæˆæŒ‡ä»¤æµå’Œå†…å­˜è¯·æ±‚äº‹ä»¶ï¼Œä¼°ç®—æ ¸å¿ƒå†…éƒ¨å»¶è¿Ÿã€‚è¿™äº›äº‹ä»¶è¢«æ‰”è¿› ContentionSimã€‚
- Weave Phase (Contention Sim): ContentionSim æ¥ç®¡æ‰€æœ‰äº‹ä»¶ï¼Œæ¨¡æ‹Ÿå®ƒä»¬åœ¨ç¼“å­˜å±‚æ¬¡ã€ç½‘ç»œå’Œå†…å­˜ä¸­çš„äº¤äº’ã€æ’é˜Ÿå’Œç«äº‰ï¼Œè®¡ç®—æœ€ç»ˆçš„ç³»ç»Ÿå»¶è¿Ÿã€‚

#### åˆå§‹åŒ–é˜¶æ®µ

è°ƒç”¨é¡ºåºï¼š zsim.cpp:SimInit -> ContentionSim() -> postInit() -> initStats()

å­è¿‡ç¨‹ä¸å®ç°ï¼š

1. ContentionSim() æ„é€ å‡½æ•°ï¼š
    - åˆ›å»ºåŸŸ (Domains)ï¼šzsim ä¸ºäº†å¹¶è¡ŒåŒ–ï¼Œå°†ç¡¬ä»¶ç³»ç»Ÿåˆ’åˆ†ä¸ºå¤šä¸ªâ€œåŸŸâ€ï¼ˆDomainï¼‰ã€‚é€šå¸¸ä¸€ä¸ª Domain å¯¹åº”ä¸€ä¸ª Cache Bank æˆ– Memory Controllerã€‚domains æ•°ç»„è¢«åˆ†é…ã€‚
    - åˆ†é…çº¿ç¨‹ï¼šåˆ›å»º numSimThreads ä¸ªåå°çº¿ç¨‹ã€‚æ¯ä¸ªçº¿ç¨‹è´Ÿè´£æ¨¡æ‹Ÿä¸€éƒ¨åˆ† Domainã€‚
    - å¯åŠ¨çº¿ç¨‹ï¼šPIN_SpawnInternalThread(SimThreadTrampoline, ...) å¯åŠ¨è¿™äº›çº¿ç¨‹ã€‚å®ƒä»¬å¯åŠ¨åä¼šç«‹å³åœ¨ futex_lock ä¸Šé˜»å¡ï¼Œç­‰å¾…å”¤é†’ã€‚
    - åˆå§‹åŒ–é˜Ÿåˆ—ï¼šæ¯ä¸ª Domain éƒ½æœ‰ä¸€ä¸ª PrioQueueï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ï¼Œç”¨äºå­˜æ”¾æŒ‰æ—¶é—´æ’åºçš„ TimingEventã€‚
2. postInit()ï¼šæ£€æŸ¥ç³»ç»Ÿä¸­æœ‰æ²¡æœ‰æ ¸å¿ƒéœ€è¦äº‰ç”¨æ¨¡æ‹Ÿ (needsCSim())ã€‚å¦‚æœæ˜¯çº¯åŠŸèƒ½æ¨¡æ‹Ÿï¼ˆå¦‚å¿«è¿›ï¼‰ï¼ŒskipContention ä¼šè¢«è®¾ä¸º trueï¼Œè·³è¿‡åç»­æ‰€æœ‰å·¥ä½œã€‚

#### Bound Phase

åœ¨è¿™ä¸ªé˜¶æ®µï¼ŒCPU æ ¸å¿ƒåœ¨ Pin çš„æ§åˆ¶ä¸‹æ‰§è¡ŒæŒ‡ä»¤ã€‚ContentionSim åœ¨æ­¤é˜¶æ®µä¸»è¦æ‰®æ¼”æ¥æ”¶å™¨çš„è§’è‰²ã€‚åŠ¨ä½œï¼šäº‹ä»¶å…¥é˜Ÿ (enqueue / enqueueSynced)

å­è¿‡ç¨‹ï¼š

1. äº‹ä»¶äº§ç”Ÿï¼šå½“æ ¸å¿ƒæ¨¡æ‹Ÿåˆ° Cache è®¿é—®ã€DRAM åˆ·æ–° (RefreshEvent) æˆ–å‘¨æœŸæ€§ä»»åŠ¡ (TickEvent) æ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ªç»§æ‰¿è‡ª TimingEvent çš„å¯¹è±¡ã€‚
2. å…¥é˜Ÿ (enqueueSynced)ï¼š
    - æ ¸å¿ƒè°ƒç”¨æ­¤å‡½æ•°å°†äº‹ä»¶æ”¾å…¥ç›®æ ‡ Domain çš„ä¼˜å…ˆé˜Ÿåˆ—ä¸­ã€‚
    - å¿…é¡»åŠ é” (pqLock)ï¼Œå› ä¸ºå¤šä¸ªæ ¸å¿ƒå¯èƒ½åŒæ—¶å‘åŒä¸€ä¸ª L3 Cache Domain å‘é€è¯·æ±‚ã€‚
    - äº‹ä»¶è¢«æ ‡è®°ä¸Š startCycleï¼ˆå‘èµ·æ—¶é—´ï¼‰ã€‚

ç‰¹æ®Šäº‹ä»¶ï¼šè·¨åŸŸè®¿é—® (enqueueCrossing)

- å½“ä¸€ä¸ªäº‹ä»¶ä»ä¸€ä¸ª Domainï¼ˆæ¯”å¦‚ L2 Cacheï¼‰æµå‘å¦ä¸€ä¸ª Domainï¼ˆæ¯”å¦‚ L3 Cacheï¼‰æ—¶ï¼Œä¼šäº§ç”Ÿ CrossingEventã€‚
- enqueueCrossing è´Ÿè´£å¤„ç†è¿™ç§ä¾èµ–å…³ç³»ï¼Œç¡®ä¿äº‹ä»¶é“¾çš„æ­£ç¡®æ€§ã€‚å®ƒå¯èƒ½ä¼šæŠŠæ–°äº‹ä»¶æŒ‚åœ¨æ—§äº‹ä»¶ï¼ˆlastCrossingï¼‰åé¢ï¼Œå½¢æˆå› æœé“¾ã€‚

#### Weave Phase

å½“æ‰€æœ‰æ ¸å¿ƒéƒ½è·‘å®Œå½“å‰çš„ Phaseï¼ˆæ¯”å¦‚ 10000 å‘¨æœŸï¼‰åï¼Œè°ƒåº¦å™¨è°ƒç”¨ EndOfPhaseActionsã€‚

è°ƒç”¨é¡ºåºï¼š zsim.cpp:EndOfPhaseActions -> ContentionSim::simulatePhase(limit)

å­è¿‡ç¨‹ä¸å®ç°ï¼š

1. simulatePhase(limit)
    - æ ¸å¿ƒå‡†å¤‡ï¼šè°ƒç”¨æ‰€æœ‰ zinfo->cores[i]->cSimStart()ã€‚
    - å”¤é†’æ¨¡æ‹Ÿçº¿ç¨‹ï¼šfutex_unlock(&simThreads[i].wakeLock)ã€‚å”¤é†’æ‰€æœ‰åå°æ¨¡æ‹Ÿçº¿ç¨‹ã€‚
    - ç­‰å¾…å®Œæˆï¼šä¸»çº¿ç¨‹è‡ªå·±è°ƒç”¨ futex_lock_nospin(&waitLock) è¿›å…¥ç¡çœ ï¼Œç­‰å¾…æ‰€æœ‰åå°çº¿ç¨‹å¹²å®Œæ´»ã€‚
2. simThreadLoop -> simulatePhaseThread (åå°çº¿ç¨‹å·¥ä½œé€»è¾‘)
    - æ¯ä¸ªçº¿ç¨‹è´Ÿè´£æ¨¡æ‹Ÿå®ƒç®¡è¾–çš„è‹¥å¹²ä¸ª Domainï¼ˆä» firstDomain åˆ° supDomainï¼‰ã€‚
    - å¦‚æœåªç®¡ 1 ä¸ª Domainï¼šè¿™æ˜¯ä¸€ä¸ªä¼˜åŒ–è·¯å¾„ã€‚å®ƒåªéœ€ç®€å•åœ°ä» PrioQueue ä¸­å–å‡ºæœ€æ—©çš„äº‹ä»¶ (dequeue)ï¼Œè°ƒç”¨äº‹ä»¶çš„ run() æˆ– simulate() æ–¹æ³•ï¼Œç„¶åå¤„ç†ä¸‹ä¸€ä¸ªï¼Œç›´åˆ°æ—¶é—´æ¨è¿›åˆ° limitã€‚
    - å¦‚æœç®¡å¤šä¸ª Domain (å¤šè·¯å½’å¹¶)ï¼š
        - å®ƒéœ€è¦ç»´æŠ¤è¿™äº› Domain ä¹‹é—´çš„æ—¶é—´åŒæ­¥ã€‚
        - å®ƒä½¿ç”¨ä¸€ä¸ªæœ¬åœ°ä¼˜å…ˆé˜Ÿåˆ— (domPq) æ¥å†³å®šâ€œå“ªä¸ª Domain çš„ä¸‹ä¸€ä¸ªäº‹ä»¶æœ€æ—©å‘ç”Ÿâ€ã€‚
        - å¤æ‚çš„åŒæ­¥é€»è¾‘ï¼š
            - å®ƒä¸ä»…è¦å¤„ç†å†…éƒ¨äº‹ä»¶ï¼Œè¿˜è¦å¤„ç†è·¨åŸŸäº‹ä»¶ (CrossingEvent)ã€‚
            - CrossingEvent æœ‰ä¸€ä¸ªæ£˜æ‰‹çš„é—®é¢˜ï¼šæº Domain çš„æ—¶é—´å¿…é¡»å…ˆæ¨è¿›ï¼Œç›®æ ‡ Domain æ‰èƒ½å®‰å…¨åœ°å¤„ç†è¯¥äº‹ä»¶ã€‚
            - ä»£ç ä¸­çš„ stalledQueue å’Œ nextStalledQueue å°±æ˜¯ä¸ºäº†å¤„ç†è¿™ç§ä¾èµ–ã€‚å¦‚æœä¸€ä¸ª Domain ç­‰å¾…å¤–éƒ¨è¾“å…¥ï¼ˆprio > 0ï¼‰ï¼Œå®ƒä¼šè¢«æ”¾å…¥ Stall é˜Ÿåˆ—æš‚æ—¶æç½®ã€‚
3. äº‹ä»¶æ¨¡æ‹Ÿ (TimingEvent::simulate / CrossingEvent::simulate)
    - è¿™æ˜¯å…·ä½“çš„ç¡¬ä»¶é€»è¾‘ã€‚ä¾‹å¦‚ TickEvent ä¼šè°ƒç”¨ DDRMemory::tick()ã€‚
    - CrossingEvent ä»£è¡¨ä¸¤ä¸ªç‹¬ç«‹æ—¶é’ŸåŸŸä¹‹é—´çš„æ¡æ‰‹ã€‚
        - simulate ä¼šæ£€æŸ¥æº Domain çš„æ—¶é—´ (srcDomainCycleAtDone)ã€‚
        - å¦‚æœæºæ—¶é—´è¿˜æ²¡èµ¶ä¸Šæ¥ï¼ŒCrossingEvent ä¼šé‡æ–°å…¥é˜Ÿ (requeue)ï¼Œç¨åå†è¯•ã€‚è¿™æ¨¡æ‹Ÿäº†â€œæ•°æ®è¿˜æ²¡ä¼ è¿‡æ¥â€çš„æƒ…å†µã€‚
        - ä¸€æ—¦æºæ—¶é—´æ»¡è¶³æ¡ä»¶ï¼Œå®ƒè®¡ç®—ä¼ è¾“å»¶è¿Ÿï¼Œæ›´æ–°ç›®æ ‡æ—¶é—´ã€‚
4. é˜¶æ®µç»“æŸ
    - å½“æ‰€æœ‰åå°çº¿ç¨‹éƒ½æŠŠæ—¶é—´æ¨è¿›åˆ°äº† limitï¼Œæœ€åä¸€ä¸ªå®Œæˆçš„çº¿ç¨‹ä¼šè§£é” waitLockã€‚
    - ä¸»çº¿ç¨‹é†’æ¥ï¼Œè°ƒç”¨ cSimEnd() é€šçŸ¥æ ¸å¿ƒï¼Œç„¶åç»“æŸ EndOfPhaseActionsã€‚

### EventQueue

zsim ä¸­çš„ä¸¤ä¸ªæ—¶é—´å°ºåº¦ï¼š

- å¾®è§‚å°ºåº¦ (Cycle-Level)ï¼šç”± ContentionSim ç®¡ç†ã€‚å¤„ç† Cache è®¿é—®ã€å†…å­˜äº‰ç”¨ï¼Œç²¾åº¦ä¸º 1 æ—¶é’Ÿå‘¨æœŸã€‚
- å®è§‚å°ºåº¦ (Phase-Level)ï¼šç”± EventQueue ç®¡ç†ã€‚å¤„ç†ç»Ÿè®¡æ•°æ®è½¬å‚¨ã€å¿«è¿›åˆ‡æ¢ã€æ­»é”æ£€æµ‹ç­‰ï¼Œç²¾åº¦ä¸º 1 ä¸ª Phaseï¼ˆé€šå¸¸æ˜¯ 10,000 åˆ° 100,000 ä¸ªå‘¨æœŸï¼‰ã€‚

EventQueue çš„ç”Ÿå‘½å‘¨æœŸéå¸¸æ¸…æ™°ï¼Œä¸»è¦ç”± insertï¼ˆç”Ÿäº§è€…ï¼‰å’Œ tickï¼ˆæ¶ˆè´¹è€…ï¼‰ç»„æˆã€‚

1. ç”Ÿäº§è€…ï¼šinsertã€‚ä»»ä½•ç»„ä»¶ï¼ˆCore, Scheduler, FFIï¼‰éƒ½å¯ä»¥åœ¨ä»»ä½•æ—¶å€™è°ƒç”¨ insert æ¥é¢„çº¦ä¸€ä¸ªæœªæ¥çš„ä»»åŠ¡ã€‚
    - è°ƒç”¨ç¤ºä¾‹ï¼š
        - FFI (å¿«è¿›)ï¼šzinfo->eventQueue->insert(makeAdaptiveEvent(...)) â€”â€” åœ¨æ‰§è¡Œäº† X æ¡æŒ‡ä»¤åçš„é‚£ä¸ª Phase å”¤é†’ã€‚
        - Stats (ç»Ÿè®¡)ï¼šzinfo->eventQueue->insert(new PeriodicStatsDumpEvent(...)) â€”â€” æ¯éš” 100 ä¸ª Phase dumpä¸€æ¬¡ç»Ÿè®¡æ•°æ®ã€‚
2. æ¶ˆè´¹è€…ï¼štick (æ¯ä¸ª Phase ç»“æŸæ—¶)ã€‚è¿™æ˜¯ EventQueue çœŸæ­£å·¥ä½œçš„æ—¶åˆ»ã€‚
    - è°ƒç”¨é“¾è·¯ï¼š
        1. zsim.cpp (PinTool ä¸»å¾ªç¯æˆ–åå°çº¿ç¨‹) è§¦å‘ EndOfPhaseActions()ã€‚
        2. EndOfPhaseActions() åšå®Œä¸€äº›æ‚äº‹ï¼ˆå¦‚æ£€æŸ¥æš‚åœï¼‰ã€‚
        3. è°ƒç”¨ zinfo->eventQueue->tick()ã€‚

### Scheduler

å®ƒçš„æ ¸å¿ƒä»»åŠ¡æ˜¯è§£å†³ M ä¸ªè½¯ä»¶çº¿ç¨‹ï¼ˆGuest Threadsï¼‰å¦‚ä½•è·‘åœ¨ N ä¸ªæ¨¡æ‹Ÿæ ¸å¿ƒï¼ˆHost Cores/Contextsï¼‰ä¸Šçš„é—®é¢˜ã€‚

zsim é‡‡ç”¨çš„æ˜¯ Round-Robinï¼ˆè½®è¯¢ï¼‰ è°ƒåº¦ç­–ç•¥ï¼Œå¹¶ç»“åˆäº†Barrierï¼ˆå±éšœï¼‰ åŒæ­¥æœºåˆ¶æ¥æ¨è¿›æ¨¡æ‹Ÿæ—¶é—´ï¼ˆPhasesï¼‰ã€‚

å…³é”®çŠ¶æ€å’Œç»“æ„ï¼š

- gid (Global ID): è½¯ä»¶çº¿ç¨‹ ID (PID << 16 | TID)ã€‚
- cid (Core ID): æ¨¡æ‹Ÿç¡¬ä»¶æ ¸å¿ƒ ID (0 ~ numCores-1)ã€‚
- ThreadInfo: è½¯ä»¶çº¿ç¨‹çš„çŠ¶æ€ï¼ˆRUNNING, BLOCKED, SLEEPING, QUEUEDï¼‰ã€‚
- ContextInfo: ç¡¬ä»¶æ ¸å¿ƒçš„çŠ¶æ€ï¼ˆIDLE, USEDï¼‰ã€‚
- runQueue: æƒ³è¿è¡Œä½†æ²¡æœ‰æ ¸å¿ƒç”¨çš„çº¿ç¨‹é˜Ÿåˆ—ã€‚
- freeList: ç©ºé—²çš„ã€æ²¡æœ‰çº¿ç¨‹è·‘çš„æ ¸å¿ƒé˜Ÿåˆ—ã€‚

`Scheduler` é€šè¿‡ä¸€ç»„ Finite State Machine (FSM) æ¥ç®¡ç†çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸã€‚

#### A. Initialization & Registration

- **System Init**: `SimInit` è°ƒç”¨ `new Scheduler`ï¼Œåˆå§‹åŒ– `contexts` å‘é‡å¹¶å°†æ‰€æœ‰æ ¸å¿ƒç½®å…¥ `freeList`ã€‚åŒæ—¶å¯åŠ¨ **Watchdog Thread** ç”¨äº Liveness Monitoringã€‚
- **Thread Registration**: å½“ Pin æˆªè·çº¿ç¨‹åˆ›å»ºäº‹ä»¶ (`SimThreadStart`) æ—¶ï¼Œè°ƒç”¨ `sched->start`ã€‚è°ƒåº¦å™¨åœ¨ `gidMap` ä¸­å®ä¾‹åŒ– `ThreadInfo`ï¼Œåˆå§‹çŠ¶æ€ç½®ä¸º `STARTED`ã€‚

#### B. Arbitration â€”â€” `join` Process

å½“ Guest Thread å¯åŠ¨æˆ–ä»é˜»å¡çŠ¶æ€è¿”å›æ—¶ï¼Œéœ€è°ƒç”¨ `join` ç”³è¯·è®¡ç®—èµ„æº (`cid`)ã€‚

1. **State Check**: è‹¥çº¿ç¨‹çŠ¶æ€ä¸º `OUT`ï¼ˆå³åˆšæ‰§è¡Œå®Œ Syscall ç¦»å¼€ï¼Œä¸”ä¿ç•™äº† Contextï¼‰ï¼Œåˆ™æ‰§è¡Œ **Fast Path Recovery**ï¼Œç›´æ¥æ¢å¤ä¸º `RUNNING` å¹¶åŠ å…¥ Barrierã€‚
2. **Scheduling Decision (`schedThread`)**: è‹¥çº¿ç¨‹å¤„äº `BLOCKED` æˆ– `STARTED`ï¼Œè°ƒåº¦å™¨æŒ‰ä»¥ä¸‹ä¼˜å…ˆçº§å°è¯•åˆ†é…èµ„æºï¼š
    - **Affinity**: æ£€æŸ¥è¯¥çº¿ç¨‹ä¸Šæ¬¡æŒæœ‰çš„ `cid` æ˜¯å¦ä¸º `IDLE`ã€‚
    - **Free Resources**: æ£€æŸ¥ `freeList` æ˜¯å¦æœ‰å¯ç”¨ Contextã€‚
    - **Preemption**: æ£€æŸ¥ `outQueue`ï¼Œå¯»æ‰¾å¤„äº `OUT` çŠ¶æ€çš„çº¿ç¨‹æ‰€å ç”¨çš„ `ContextInfo`ï¼Œæ‰§è¡Œ `deschedule` å°†å…¶ Context å‰¥ç¦»ï¼Œä»¥å›æ”¶èµ„æºã€‚
3. **Arbitration Result**:
    - **Success**: è°ƒç”¨ `schedule` å»ºç«‹ `ThreadInfo` ä¸ `ContextInfo` çš„åŒå‘æ˜ å°„ã€‚
    - **Failure**: å°†çº¿ç¨‹çŠ¶æ€ç½®ä¸º `QUEUED` å¹¶å‹å…¥ `runQueue`ã€‚çº¿ç¨‹éšå³åœ¨ Host çš„ `futex` ä¸ŠæŒ‚èµ· (`waitForContext`)ï¼Œè¿›å…¥ Sleep çŠ¶æ€ç­‰å¾… Wakeupã€‚

#### C. Execution & Synchronization â€”â€” `sync` Process

è¿™æ˜¯æ¨¡æ‹Ÿçš„ä¸»å¾ªç¯ï¼Œé©±åŠ¨ **Discrete Time Stepping**ã€‚

1. **Barrier Synchronization**: çº¿ç¨‹è°ƒç”¨ `sched->sync` è¿›å…¥ `Barrier`ã€‚
2. **Phase Transition (`callback`)**:
    - å½“æ‰€æœ‰ Active Threads åˆ°è¾¾ Barrier æ—¶ï¼Œè§¦å‘ `Scheduler::callback`ã€‚
    - å…¨å±€æ¨¡æ‹Ÿæ—¶é—´ `curPhase` é€’å¢ã€‚
    - **Deadline Check**: æ‰«æ `sleepQueue`ï¼Œå”¤é†’ (`wakeup`) é‚£äº› `wakeupPhase` å·²åˆ°æœŸçš„çº¿ç¨‹ï¼Œå°†å…¶ç§»è‡³ `runQueue` å‚ä¸ç«äº‰ã€‚
    - **Round-Robin Scheduling (`schedTick`)**: è‹¥è¾¾åˆ° `schedQuantum`ï¼Œè§¦å‘å¼ºåˆ¶è°ƒåº¦ã€‚ç®—æ³• Shuffle æ ¸å¿ƒé¡ºåºï¼Œä» `runQueue` ä¸­é€‰å–çº¿ç¨‹ï¼Œå¹¶æŒ‡å®šå½“å‰è¿è¡Œçš„æŸä¸ªçº¿ç¨‹ä¸º Victim (`victimTh`)ï¼Œè®¾ç½®å…¶ `handoffThread` æŒ‡é’ˆï¼Œå‡†å¤‡ **Context Switch**ã€‚
3. **Context Switch (Handoff)**:
    - ä» Barrier è¿”å›åï¼Œçº¿ç¨‹æ£€æŸ¥è‡ªèº«çš„ `handoffThread` å­—æ®µã€‚
    - è‹¥éç©ºï¼Œå½“å‰çº¿ç¨‹æ‰§è¡Œ **Cooperative Context Switch**ï¼š`deschedule` è‡ªèº«ï¼Œ`schedule` å¹¶ `wakeup` ç›®æ ‡çº¿ç¨‹ï¼Œéšåè‡ªèº«æŒ‚èµ·ã€‚

#### D. Yielding â€”â€” `leave` Process

å½“ Guest Thread æ‰§è¡Œ Syscall è¿›å…¥ Kernel Mode æ—¶ï¼Œéœ€é‡Šæ”¾æ¨¡æ‹Ÿæ ¸å¿ƒèµ„æºã€‚

1. **Syscall Interception**: `SyscallEnter` è§¦å‘ `sched->syscallLeave`ã€‚
2. **Optimistic Optimization (Fake Leave)**:
    - å¯¹äºéé˜»å¡çš„çŸ­ Syscallï¼Œzsim é‡‡ç”¨ **Speculative Execution** ç­–ç•¥ï¼Œä¸çœŸæ­£é‡Šæ”¾ `cid`ï¼Œè€Œæ˜¯åˆ›å»ºä¸€ä¸ª `FakeLeaveInfo` è®°å½•ã€‚è¿™é¿å…äº†é¢‘ç¹æ›´æ–°å…¨å±€çŠ¶æ€çš„ Overheadã€‚
3. **True Leave**:
    - è‹¥ Syscall åœ¨ Blacklist ä¸­ï¼ˆå·²çŸ¥ä¼šé˜»å¡ï¼‰ï¼Œæˆ–çº¿ç¨‹è¢«æ ‡è®°ä¸º Sleepï¼Œåˆ™æ‰§è¡Œ `leave`ã€‚
    - **Context Detachment**: å°è¯•å°†å½“å‰ `cid` è½¬äº¤ç»™ `runQueue` ä¸­çš„ç­‰å¾…çº¿ç¨‹ã€‚è‹¥æ— ç­‰å¾…çº¿ç¨‹ï¼Œåˆ™å°† `ContextInfo` å½’è¿˜è‡³ `freeList`ï¼ˆæˆ–åœ¨ä¿ç•™ Affinity çš„å‰æä¸‹æ ‡è®°ä¸º `OUT`ï¼‰ã€‚
    - çº¿ç¨‹é€€å‡º Barrierï¼Œä¸å†å‚ä¸å½“å‰ Phase çš„åŒæ­¥ã€‚

#### Watchdog Thread

`watchdogThreadFunc` æ˜¯ä¸€ä¸ªç‹¬ç«‹è¿è¡Œçš„ Daemon Threadï¼Œè´Ÿè´£ Deadlock Detection å’Œ Recoveryã€‚

- **Deadlock Detection**: ç›‘æ§ `curPhase` çš„æ¨è¿›ã€‚è‹¥é•¿æ—¶é—´åœæ»ï¼Œåˆ¤å®šä¸º Deadlockã€‚
- **Fake Leave Correction**: ç›‘æ§ `fakeLeaves` é˜Ÿåˆ—ã€‚è‹¥å‘ç°æŸä¸ª "Fake Leave" çš„çº¿ç¨‹é•¿æœŸæœªè¿”å›ï¼ˆå³ Speculation å¤±è´¥ï¼ŒSyscall å‘ç”Ÿäº†å®é™…é˜»å¡ï¼‰ï¼ŒWatchdog ä¼šå¼ºåˆ¶æ‰§è¡Œ `finishFakeLeave` -> `leave` åºåˆ—ï¼Œå°†å…¶è½¬æ¢ä¸º "True Leave"ï¼Œä»è€Œé‡Šæ”¾æ ¸å¿ƒèµ„æºï¼Œè§£é™¤ Deadlockã€‚è¯¥ Syscall éšåä¼šè¢«åŠ å…¥ Blacklistã€‚
- **Time Advancement**: å½“ç³»ç»Ÿå¤„äº Idle çŠ¶æ€ï¼ˆæ‰€æœ‰çº¿ç¨‹å‡åœ¨ `sleepQueue` æˆ–é˜»å¡ï¼‰æ—¶ï¼ŒWatchdog è´Ÿè´£ç©ºè½¬æ¨è¿›æ¨¡æ‹Ÿæ—¶é—´ï¼Œç›´åˆ°æœ€è¿‘çš„ Wakeup æ—¶é—´ç‚¹ã€‚

#### Virtualization Support

- **Time Virtualization**: é€šè¿‡ `PatchNanosleep` ç­‰ Hooksï¼Œå°† Guest çš„çº³ç§’çº§ Sleep æ˜ å°„ä¸º Simulator çš„ `Phase` è®¡æ•°ã€‚
- **Futex Matching**: æ‹¦æˆª `SYS_futex` è°ƒç”¨ï¼Œé€šè¿‡ `notifyFutexWakeStart` ç­‰æ¥å£è·Ÿè¸ª Host å±‚çš„ Thread Wakeup äº‹ä»¶ï¼Œç¡®ä¿ Simulator å†…éƒ¨çš„ Timestamp ä¸ Causality ä¸€è‡´ã€‚

### TakeBarrier

`TakeBarrier` æ˜¯ **Guest Thread** åœ¨å®Œæˆäº†ä¸€ä¸ª **Time Quantum (æ—¶é—´ç‰‡/Phase)** çš„æœ¬åœ°æŒ‡ä»¤æ¨¡æ‹Ÿåï¼Œä¸»åŠ¨è°ƒç”¨çš„åŒæ­¥å‡½æ•°ã€‚å®ƒæ˜¯è¿æ¥ **Core Model** ä¸ **Scheduler** çš„æ¡¥æ¢ã€‚

#### Triggering Condition

æ­£å¦‚ `NullCore::BblFunc`, `OOOCore::BblFunc` ç­‰ä»£ç æ‰€ç¤ºï¼Œæ¯ä¸ª Core æ¨¡å‹éƒ½æœ‰ä¸€ä¸ªæœ¬åœ°æ—¶é’Ÿ `curCycle`ã€‚

- å½“ `core->curCycle > core->phaseEndCycle` æ—¶ï¼ˆå³å½“å‰ Phase çš„æ—¶é—´é…é¢ç”¨å°½ï¼‰ï¼ŒCore æ¨¡æ‹Ÿå¾ªç¯ä¸­æ–­ã€‚
- è°ƒç”¨ `TakeBarrier(tid, cid)`ã€‚

#### Core Logic

1. **è¿›å…¥åŒæ­¥å±éšœ (Barrier Entry)**:

      - è°ƒç”¨ `zinfo->sched->sync(procIdx, tid, cid)`ã€‚
      - **è¡Œä¸º**ï¼šå½“å‰çº¿ç¨‹åœ¨æ­¤å¤„æŒ‚èµ· (Blocked)ï¼Œç­‰å¾…æ‰€æœ‰å…¶ä»–çº¿ç¨‹åˆ°è¾¾å±éšœã€‚
      - **å‰¯ä½œç”¨**ï¼šå¦‚æœæ˜¯æœ€åä¸€ä¸ªåˆ°è¾¾å±éšœçš„çº¿ç¨‹ï¼Œå®ƒä¼šè§¦å‘ `Scheduler::callback`ï¼Œè¿›è€Œè§¦å‘ `EndOfPhaseActions`ï¼ˆè§ä¸‹æ–‡ï¼‰ã€‚

2. **æ›´æ–°æ ¸å¿ƒæ˜ å°„ (Context Update)**:

      - `sync` è¿”å›åï¼Œæ„å‘³ç€ Barrier è§£é™¤ï¼Œä¸” **Scheduler å¯èƒ½å·²ç»æ‰§è¡Œäº†è°ƒåº¦å†³ç­–**ã€‚
      - è¿”å›å€¼ `newCid` æ˜¯ Scheduler åˆ†é…ç»™è¯¥çº¿ç¨‹çš„ **æ–°ç‰©ç†æ ¸å¿ƒ ID**ã€‚
      - `clearCid(tid)` / `setCid(tid, newCid)`ï¼šæ›´æ–°å…¨å±€æ˜ å°„è¡¨ï¼Œåæ˜ çº¿ç¨‹å¯èƒ½å‘ç”Ÿçš„è¿ç§»ã€‚

3. **çŠ¶æ€è½¬æ¢å¤„ç† (State Transition Handling)**:

      - **Fast Forward Check**: å¦‚æœæ¨¡æ‹Ÿå™¨åˆ‡æ¢åˆ°äº†å¿«è¿›æ¨¡å¼ (`isInFastForward`)ï¼Œå½“å‰çº¿ç¨‹æ‰§è¡Œ `SimThreadFini`ï¼ˆæ³¨é”€ï¼‰ï¼Œåˆ‡æ¢ `fPtrs` ä¸ºå¿«è¿›æŒ‡é’ˆï¼Œå¹¶åœ¨æ­¤å¤„ç»ˆæ­¢è¯¦ç»†æ¨¡æ‹Ÿã€‚
      - **Termination Check**: å¦‚æœæ¨¡æ‹Ÿç»“æŸï¼Œè°ƒç”¨ `SimEnd`ã€‚
      - **Context Switch**: å¦‚æœæ²¡æœ‰ç‰¹æ®ŠçŠ¶æ€å˜åŒ–ï¼Œæ›´æ–° `fPtrs[tid]` ä¸ºæ–°æ ¸å¿ƒ (`cores[newCid]`) çš„å‡½æ•°æŒ‡é’ˆã€‚è¿™æ˜¯ä¸ºäº†æ”¯æŒå¼‚æ„æ ¸å¿ƒæ¨¡æ‹Ÿï¼ˆä¾‹å¦‚ä»ä¹±åºæ ¸åˆ‡æ¢åˆ°é¡ºåºæ ¸ï¼‰ï¼Œå°½ç®¡ zsim é€šå¸¸æ˜¯åŒæ„çš„ã€‚

4. **è¿”å›æ–°æ ¸å¿ƒ ID**:

      - å‡½æ•°è¿”å› `newCid`ã€‚
      - **é‡è¦æœºåˆ¶**ï¼šåœ¨ `BblFunc` çš„å¾ªç¯ä¸­ï¼š

        ```cpp
        if (newCid != cid) break;
        ```

        å¦‚æœå‘ç”Ÿ **Context Switch (ä¸Šä¸‹æ–‡åˆ‡æ¢)**ï¼Œçº¿ç¨‹å¿…é¡»ç«‹å³è·³å‡ºå½“å‰çš„ `BblFunc` å¾ªç¯ã€‚å› ä¸º `BblFunc` æ˜¯ç‰¹å®š Core å¯¹è±¡ï¼ˆå¦‚ `OOOCore`ï¼‰çš„æˆå‘˜å‡½æ•°ï¼Œå¦‚æœçº¿ç¨‹å·²ç»è¢«è°ƒåº¦åˆ°äº†å¦ä¸€ä¸ª Coreï¼Œå®ƒå°±ä¸èƒ½ç»§ç»­æ“ä½œå½“å‰ Core å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ï¼ˆå¦‚ ROB, L1 Cacheï¼‰ï¼Œå¦åˆ™ä¼šå¯¼è‡´ **Race Condition** æˆ–æ•°æ®æŸåã€‚

### EndOfPhaseActions

`EndOfPhaseActions` æ˜¯ **Global Synchronization Barrier** æœŸé—´æ‰§è¡Œçš„å…¨å±€å›è°ƒã€‚

**æ³¨æ„**ï¼šè™½ç„¶å®ƒåœ¨ä»£ç ä¸Šæ˜¯ä¸€ä¸ªç‹¬ç«‹å‡½æ•°ï¼Œä½†åœ¨æ‰§è¡Œæµä¸Šï¼Œå®ƒæ˜¯ç”±**æœ€åä¸€ä¸ªè¿›å…¥ `TakeBarrier` çš„çº¿ç¨‹**åœ¨ `Scheduler::callback` å†…éƒ¨è°ƒç”¨çš„ã€‚æ­¤æ—¶ï¼Œæ‰€æœ‰å…¶ä»–æ¨¡æ‹Ÿçº¿ç¨‹éƒ½å¤„äº `futex_wait` çŠ¶æ€ï¼ˆè¢«å±éšœé˜»æ‹¦ï¼‰ã€‚

#### Triggering Condition

1. **æ€§èƒ½åˆ†æåŸ‹ç‚¹ (Profiling Instrumentation)**:

      - `zinfo->profSimTime->transition(PROF_WEAVE)`ï¼šæ ‡è®°æ¨¡æ‹Ÿå™¨è¿›å…¥ **Weave Phase**ã€‚ç»Ÿè®¡æ—¶é—´å°†è®¡å…¥äº‰ç”¨æ¨¡æ‹Ÿå¼€é”€ã€‚

2. **å…¨å±€æš‚åœä¸æµæ§ (Global Pause & Flow Control)**:

      - æ£€æŸ¥ `globalPauseFlag` æˆ– `globalSyncedFFProcs`ã€‚
      - å¦‚æœåœ¨åŒæ­¥ç‚¹å‘ç°éœ€è¦æš‚åœæˆ–åˆ‡æ¢æ¨¡å¼ï¼Œä¸»æ§çº¿ç¨‹ä¼šåœ¨æ­¤å¤„ **Busy-Wait (è‡ªæ—‹ç­‰å¾…)**ï¼Œç›´åˆ°å¤–éƒ¨æ¡ä»¶è§£é™¤ã€‚è¿™æ˜¯ä¸ºäº†é˜²æ­¢åœ¨ Phase ä¸­é—´çŠ¶æ€ä¸ä¸€è‡´æ—¶è¿›è¡Œæ¨¡å¼åˆ‡æ¢ã€‚

3. **æ‰§è¡Œäº‰ç”¨æ¨¡æ‹Ÿ (Contention Simulation) â€”â€” æ ¸å¿ƒä»»åŠ¡**:

      - `zinfo->contentionSim->simulatePhase(...)`ã€‚
      - è¿™æ˜¯ zsim **Bound-Weave** æ¨¡å‹çš„ **Weave** é˜¶æ®µã€‚
      - åœ¨æ­¤ä¹‹å‰ï¼ˆBound Phaseï¼‰ï¼ŒCores åªæ˜¯ç”Ÿæˆäº†å¸¦æœ‰æ—¶é—´æˆ³çš„å†…å­˜è¯·æ±‚äº‹ä»¶ï¼Œæ”¾å…¥äº†é˜Ÿåˆ—ï¼Œä½†æ²¡æœ‰è®¡ç®—å®ƒä»¬åœ¨ L2/L3/DRAM é‡Œçš„æ’é˜Ÿå»¶è¿Ÿã€‚
      - æ­¤å‡½æ•°ä¼šå”¤é†’ `ContentionSim` çš„å·¥ä½œçº¿ç¨‹ï¼Œå¤„ç†è¿™äº›ç§¯å‹çš„äº‹ä»¶ï¼Œè®¡ç®—å‡ºç²¾ç¡®çš„å…¨å±€æ—¶åºï¼Œå¹¶æ›´æ–°å„ç»„ä»¶çš„çŠ¶æ€ã€‚

4. **æ¨è¿›å®è§‚äº‹ä»¶ (Event Queue Tick)**:

      - `zinfo->eventQueue->tick()`ã€‚
      - å¤„ç†å‘¨æœŸæ€§çš„å®è§‚ä»»åŠ¡ï¼ˆå¦‚æ‰“å°å¿ƒè·³ã€æ­»é”æ£€æµ‹ã€é‡‡æ ·åˆ‡æ¢ï¼‰ã€‚

5. **è¿›å…¥ä¸‹ä¸€é˜¶æ®µ**:

      - `zinfo->profSimTime->transition(PROF_BOUND)`ã€‚
      - æ ‡è®° Weave é˜¶æ®µç»“æŸï¼Œå‡†å¤‡é‡Šæ”¾æ‰€æœ‰çº¿ç¨‹å›åˆ° **Bound Phase**ã€‚

#### Core Logic

è¿™æ˜¯ä¸€ä¸ªåŸºäº **Bulk Synchronous Parallel (BSP)** æ¨¡å‹çš„æ‰§è¡Œå¾ªç¯ï¼š

1. **Bound Phase (Parallel)**:

      - æ‰€æœ‰ Guest Threads åœ¨å„è‡ªçš„ Host Core ä¸Šè¿è¡Œ `BblFunc`ã€‚
      - æ‰§è¡ŒæŒ‡ä»¤ï¼Œäº§ç”Ÿ `TimingEvent`ï¼Œç›´åˆ°æœ¬åœ°æ—¶é—´ `curCycle` è¶…è¿‡ `phaseEndCycle`ã€‚
      - è°ƒç”¨ `TakeBarrier`ã€‚

2. **Barrier Phase (Serial/Synchronous)**:

      - çº¿ç¨‹è¿›å…¥ `Scheduler`ï¼Œåœ¨ Barrier å¤„ç­‰å¾…ã€‚
      - **Last Thread Reaches Barrier**:
          - è§¦å‘ `Scheduler::callback` -\> æ›´æ–° `curPhase`ã€‚
          - è§¦å‘ `EndOfPhaseActions`ã€‚
          - æ‰§è¡Œ `ContentionSim::simulatePhase` (æ¨¡æ‹Ÿç¼“å­˜/å†…å­˜äº‰ç”¨)ã€‚
          - æ‰§è¡Œ `EventQueue::tick`ã€‚

3. **Resume (Parallel)**:

      - Barrier é‡Šæ”¾æ‰€æœ‰çº¿ç¨‹ã€‚
      - çº¿ç¨‹ä» `TakeBarrier` è¿”å›ã€‚
      - æ£€æŸ¥ `newCid`ï¼Œå¦‚æœå‘ç”Ÿäº† Context Switchï¼Œè·³è½¬åˆ°æ–° Core çš„ä»£ç æ‰§è¡Œã€‚
      - å¢åŠ  `phaseEndCycle`ï¼Œå¼€å§‹ä¸‹ä¸€ä¸ª Phase çš„æ¨¡æ‹Ÿã€‚

### AggregateStat

AggregateStat æ˜¯ statistics infrastructure ä¸­çš„ Topological Building Blockã€‚å®ƒå®ç°äº† Composite Design Patternï¼Œåœ¨ zsim çš„ statistics architecture ä¸­æ‰®æ¼” Structural Container çš„è§’è‰²ã€‚

zsim çš„ statistics æ•°æ®è¢«ç»„ç»‡æˆä¸€ä¸ª DAG (Directed Acyclic Graph) æˆ– Tree structureã€‚

- Leaf Nodesï¼šå¦‚ Counter, ScalarStat, VectorStatï¼Œå®ƒä»¬è´Ÿè´£å®é™…å­˜å‚¨ numerical dataã€‚
- Internal Nodesï¼šå³ AggregateStatã€‚å®ƒä»¬ä¸å­˜å‚¨ valueï¼Œè€Œæ˜¯ç»´æŠ¤ä¸€ä¸ªæŒ‡å‘å…¶ä»– Stat å¯¹è±¡çš„æŒ‡é’ˆåˆ—è¡¨ (`g_vector<Stat*> _children`)ã€‚

#### å±‚çº§åŒ–ç»„ç»‡ (Hierarchical Organization)

å®ƒå…è®¸æ¨¡æ‹Ÿå™¨å°†é€»è¾‘ä¸Šç›¸å…³çš„ç»Ÿè®¡æ•°æ®åˆ†ç»„ã€‚

- å°è£… (Encapsulation)ï¼šä¾‹å¦‚ï¼Œä¸€ä¸ª Cache å¯¹è±¡ä¼šåˆ›å»ºä¸€ä¸ª AggregateStatï¼Œå¹¶å°†æ‰€æœ‰ä¸è¯¥ç¼“å­˜ç›¸å…³çš„è®¡æ•°å™¨ï¼ˆHits, Missesï¼‰append åˆ°è¿™ä¸ª Aggregate ä¸­ã€‚
- å‘½åç©ºé—´ (Namespacing)ï¼šé€šè¿‡å±‚å±‚åµŒå¥—ï¼Œå½¢æˆå¦‚ system.core0.l1d.hits çš„è·¯å¾„ç»“æ„ã€‚è¿™ä½¿å¾—åç«¯ï¼ˆBackendï¼‰åœ¨è¾“å‡ºæ•°æ®æ—¶èƒ½ç”Ÿæˆç»“æ„åŒ–çš„æ—¥å¿—ï¼ˆå¦‚ç¼©è¿›çš„æ–‡æœ¬æˆ– HDF5 çš„ Groupï¼‰ã€‚

#### ç”Ÿå‘½å‘¨æœŸç®¡ç† (Lifecycle Management)

AggregateStat å¼ºåˆ¶æ‰§è¡Œä¸¥æ ¼çš„å¯å˜æ€§é˜¶æ®µ (Mutability Phases)ï¼Œä»¥ç¡®ä¿ç»Ÿè®¡ç»“æ„çš„ä¸€è‡´æ€§ï¼š

1. åˆå§‹åŒ–é˜¶æ®µ (Mutable Phase):
    - åœ¨æ¨¡æ‹Ÿå™¨å¯åŠ¨ (Init) æœŸé—´ï¼Œ_isMutable ä¸º trueã€‚
    - å„ç»„ä»¶è°ƒç”¨ init() è®¾ç½®åç§°ï¼Œå¹¶è°ƒç”¨ append() åŠ¨æ€æ„å»ºæ ‘ç»“æ„ã€‚
2. å†»ç»“é˜¶æ®µ (Finalization Phase):
    - åœ¨æ¨¡æ‹Ÿå¼€å§‹å‰ï¼Œè°ƒç”¨ makeImmutable()ã€‚
    - å‰ªæ (Pruning)ï¼šå®ƒä¼šé€’å½’åœ°æ£€æŸ¥å­èŠ‚ç‚¹ã€‚å¦‚æœä¸€ä¸ª AggregateStat ä¸åŒ…å«ä»»ä½•æœ‰æ•ˆçš„æ•°æ®èŠ‚ç‚¹ï¼ˆå³å®ƒæ˜¯ç©ºçš„ï¼‰ï¼Œå®ƒä¼šè¢«ä»æ ‘ä¸­ç§»é™¤ã€‚è¿™é˜²æ­¢äº†è¾“å‡ºæ–‡ä»¶ä¸­å‡ºç°ç©ºçš„ Groupã€‚
3. è¾“å‡ºé˜¶æ®µ (Immutable Phase): åœ¨æ¨¡æ‹Ÿç»“æŸ (SimEnd) æˆ–å‘¨æœŸæ€§è½¬å‚¨æ—¶ï¼Œåç«¯è®¿é—®è¯¥å¯¹è±¡ã€‚æ­¤æ—¶ç»“æ„å·²é”å®šï¼Œä¿è¯äº†å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„è¯»å–å®‰å…¨ï¼ˆè™½ç„¶ zsim çš„ç»Ÿè®¡è½¬å‚¨é€šå¸¸æ˜¯åºåˆ—åŒ–çš„ï¼‰ã€‚

#### æ•°æ®ç»“æ„æç¤º (Structural Hints)

æ„é€ å‡½æ•°ä¸­çš„ isRegular å‚æ•°æ˜¯ä¸€ä¸ªå¯¹åç«¯çš„å…ƒæ•°æ®æç¤º (Metadata Hint)ã€‚è¿™å…è®¸ç»“æ„åŒ–åç«¯ï¼ˆå¦‚ HDF5ï¼‰å°†è¿™äº›æ•°æ®æ‰å¹³åŒ–å­˜å‚¨ä¸ºç´§å‡‘çš„å¤šç»´æ•°ç»„ï¼ˆArray/Tableï¼‰ï¼Œè€Œä¸æ˜¯åˆ›å»ºæ•°åƒä¸ªç‹¬ç«‹çš„ Groupï¼Œä»è€Œæ˜¾è‘—æå‡å­˜å‚¨æ•ˆç‡å’Œåˆ†æé€Ÿåº¦ã€‚

- Irregular (é»˜è®¤)ï¼šå­èŠ‚ç‚¹ç»“æ„å„å¼‚ã€‚åç«¯é€šå¸¸å°†å…¶å¤„ç†ä¸ºæ ‘çš„éå†ã€‚
- Regularï¼šè¡¨ç¤ºè¯¥ Aggregate çš„æ‰€æœ‰å­èŠ‚ç‚¹éƒ½æ˜¯åŒæ„çš„ï¼ˆHomogeneousï¼‰ã€‚ä¾‹å¦‚ï¼ŒProcStats ä¸­åŒ…å« 64 ä¸ªç»“æ„å®Œå…¨ç›¸åŒçš„ Core ç»Ÿè®¡ã€‚

### PortVirtualizer

`PortVirtualizer` æ˜¯ zsim å®ç°çš„ä¸€ä¸ª**ç”¨æˆ·æ€ç½‘ç»œåœ°å€è½¬æ¢ (User-Space NAT)** å±‚ã€‚

å®ƒçš„ä¸»è¦ç›®çš„æ˜¯å°† **Guest Application**ï¼ˆè¢«æ¨¡æ‹Ÿç¨‹åºï¼‰çœ‹åˆ°çš„ **Virtual Port** ä¸ **Host OS**ï¼ˆå®¿ä¸»æ“ä½œç³»ç»Ÿï¼‰åˆ†é…çš„ **Real Port** è§£è€¦ã€‚è¿™æ ·åšæ˜¯ä¸ºäº†è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼š

1. **ç«¯å£å†²çª**ï¼šé¿å…å¤šä¸ªæ¨¡æ‹Ÿè¿›ç¨‹åŒæ—¶ç»‘å®šåŒä¸€ä¸ªå¸¸ç”¨ç«¯å£ï¼ˆå¦‚ 80ï¼‰æ—¶ï¼Œåœ¨ Host ä¸ŠæŠ¥ "Address already in use" é”™è¯¯ã€‚
2. **ç¡®å®šæ€§**ï¼šè®©æ¨¡æ‹Ÿç¨‹åºæ€»æ˜¯è®¤ä¸ºè‡ªå·±ç»‘å®šåˆ°äº†å®ƒæƒ³è¦çš„ç«¯å£ï¼Œè€Œä¸å— Host å®é™…ç½‘ç»œç¯å¢ƒçš„å½±å“ã€‚

#### Data Structures

`PortVirtualizer` ç»´æŠ¤äº†ä¸¤ä¸ªåŒå‘æ˜ å°„è¡¨ï¼Œå¹¶ä½¿ç”¨ `futex` é”ä¿è¯çº¿ç¨‹å®‰å…¨ï¼š

- `realToVirt`: æ˜ å°„ **Real Port** (Host åˆ†é…çš„ç«¯å£) $\rightarrow$ **Virtual Port** (Guest æƒ³è¦çš„ç«¯å£)ã€‚
- `virtToReal`: æ˜ å°„ **Virtual Port** $\rightarrow$ **Real Port**ã€‚
- `pvLock`: ä¿æŠ¤ä¸Šè¿°æ˜ å°„è¡¨çš„ Lockï¼Œé˜²æ­¢å¤šçº¿ç¨‹ç«äº‰ã€‚

å®ƒé€šè¿‡æ‹¦æˆªä¸‰ä¸ªå…³é”®çš„ Socket ç³»ç»Ÿè°ƒç”¨æ¥å®ç°è™šæ‹ŸåŒ–ï¼š`bind`, `getsockname`, å’Œ `connect`ã€‚

#### æ‹¦æˆª `bind()` (`PatchBind`)

å½“ Guest å°è¯•ç»‘å®šä¸€ä¸ªç«¯å£ï¼ˆä¾‹å¦‚ Virtual Port 8080ï¼‰ï¼š

1. **Pre-Call (è°ƒç”¨å‰)**:
      - zsim æ‹¦æˆª `bind` è°ƒç”¨ã€‚
      - è·å– Guest æƒ³è¦ç»‘å®šçš„ Virtual Port (8080)ã€‚
      - **ç¯¡æ”¹å‚æ•°**ï¼šå°†ä¼ ç»™å†…æ ¸çš„ç«¯å£å·ä¿®æ”¹ä¸º **0**ã€‚åœ¨ Socket ç¼–ç¨‹ä¸­ï¼Œç»‘å®šç«¯å£ 0 æ„å‘³ç€è®© OS è‡ªåŠ¨åˆ†é…ä¸€ä¸ªå¯ç”¨çš„ **Ephemeral Port**ï¼ˆä¸´æ—¶ç«¯å£ï¼‰ã€‚
2. **Post-Call (è°ƒç”¨å)**:
      - Host OS è¿”å›æˆåŠŸï¼Œå¹¶å®é™…åˆ†é…äº†ä¸€ä¸ª Real Portï¼ˆå‡è®¾æ˜¯ 45123ï¼‰ã€‚
      - zsim è°ƒç”¨ `getsockname` è·å–è¿™ä¸ª Real Port (45123)ã€‚
      - **æ³¨å†Œæ˜ å°„**ï¼šè°ƒç”¨ `registerBind(8080, 45123)`ï¼Œå°†ä¸¤è€…å…³è”èµ·æ¥ã€‚
      - **æ¢å¤å‚æ•°**ï¼šå°†å†…å­˜ä¸­çš„å‚æ•°æ”¹å› 8080ï¼Œè®© Guest ä»¥ä¸ºå®ƒæˆåŠŸç»‘å®šäº† 8080ã€‚

#### æ‹¦æˆª `getsockname()` (`PatchGetsockname`)

å½“ Guest è¯¢é—® "æˆ‘ç»‘å®šäº†å“ªä¸ªç«¯å£ï¼Ÿ"ï¼š

1. **Post-Call**:
      - Host OS è¿”å› Real Port (45123)ã€‚
      - zsim æ‹¦æˆªè¿”å›å€¼ã€‚
      - **æŸ¥è¡¨**ï¼šè°ƒç”¨ `lookupVirt(45123)` æ‰¾åˆ°å¯¹åº”çš„ Virtual Port (8080)ã€‚
      - **è¦†ç›–**ï¼šå°†è¿”å›ç»“æ„ä½“ä¸­çš„ç«¯å£å·ä¿®æ”¹ä¸º 8080ã€‚Guest çœ‹åˆ°çš„å°±æ˜¯å®ƒæœ€åˆè¯·æ±‚çš„ç«¯å£ã€‚

#### æ‹¦æˆª `connect()` (`PatchConnect`)

å½“ Guest Client å°è¯•è¿æ¥ä¸€ä¸ª Serverï¼š

1. **Pre-Call**:
      - Guest è¯•å›¾è¿æ¥ Virtual Port (8080)ã€‚
      - **æŸ¥è¡¨**ï¼šzsim è°ƒç”¨ `lookupReal(8080)` æŸ¥æ‰¾å¯¹åº”çš„ Real Portã€‚
      - **ç¯¡æ”¹å‚æ•°**ï¼šå¦‚æœæ‰¾åˆ°äº†è®°å½•ï¼ˆè¯´æ˜è¿™ä¸ªç«¯å£æ˜¯å¦ä¸€ä¸ª zsim çº¿ç¨‹/è¿›ç¨‹ç»‘å®šçš„ï¼‰ï¼Œå°±å°†è¿æ¥ç›®æ ‡ä¿®æ”¹ä¸º Real Port (45123)ã€‚
      - è¿™æ ·ï¼Œè¿æ¥è¯·æ±‚å°±èƒ½æ­£ç¡®åœ°è·¯ç”±åˆ° Host ä¸Šå®é™…ç›‘å¬çš„ Socketã€‚

åˆå§‹åŒ–ä»£ç ä¸­ï¼š

```cpp
zinfo->portVirt[i] = new PortVirtualizer();
```

è¿™è¡¨æ˜ zsim æ”¯æŒ **Port Domains**ã€‚ä¸åŒçš„ Domain æ‹¥æœ‰ç‹¬ç«‹çš„ `PortVirtualizer` å®ä¾‹å’Œæ˜ å°„è¡¨ã€‚è¿™æ„å‘³ç€å¤„äºä¸åŒ Domain çš„è¿›ç¨‹å¯ä»¥å„è‡ªç»‘å®š Virtual Port 80 è€Œäº’ä¸å¹²æ‰°ï¼ˆå®ƒä»¬ä¼šåœ¨ Host ä¸Šæ˜ å°„åˆ°ä¸åŒçš„ Real Portï¼‰ï¼Œä»è€Œå®ç°äº†ç½‘ç»œå‘½åç©ºé—´çš„éš”ç¦»ã€‚

### NUMAMap

### ProcessStats

### ProcStats
