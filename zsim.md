# zsimåˆ†æ

## å¯åŠ¨æµç¨‹

### zsim harness

ç¼–è¯‘zsimé¡¹ç›®ä¼šäº§ç”Ÿä¸¤ä¸ªäºŒè¿›åˆ¶ï¼Œä¸€ä¸ªæ˜¯libzsim.soï¼Œä¸€ä¸ªæ˜¯zsimã€‚zsimçš„æœ¬ä½“æ˜¯zsim_harness.cppï¼Œè€Œä¸PINæœ‰å…³çš„zsim.cppä¼šè¢«ç¼–åˆ°libzsim.soå†…ã€‚

zsim_harnessçš„mainå‡½æ•°å†…ï¼Œæ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°å¾—åˆ°configFileçš„è·¯å¾„ï¼Œç„¶åè®¾ç½®æ¯ä¸ªsignalçš„å¤„ç†ï¼Œå‡ ä¹åªè¦æ˜¯signalå°±ç›´æ¥é‡å¼€ï¼ŒæŠŠæ•´ä¸ªè¿›ç¨‹æ ‘éƒ½å¹²æ‰ã€‚

ç„¶åæ ¹æ®sim.gmMBytesç”³è¯·å†…å­˜ï¼Œç„¶åä½¿ç”¨**PinCmd**ç±»æ¥åŠ è½½libzsim.soï¼Œç”Ÿæˆç›®æ ‡ç¨‹åºæ­£ç¡®çš„argsï¼Œå¾—åˆ°æ€»å…±çš„è¿›ç¨‹æ•°ï¼ˆä¹Ÿå°±æ˜¯éœ€è¦ä»¿çœŸå¤šå°‘ä¸ªç¨‹åºï¼Œåœ¨zsim.cfgä¸­ç”¨process0ã€process1è¿›è¡Œé…ç½®ï¼‰ï¼Œç„¶ååˆ›å»ºè¿›ç¨‹ã€‚

è¿›å…¥åˆ›å»ºè¿›ç¨‹çš„å‡½æ•°ï¼ˆLaunchProcessï¼‰åï¼Œä¼šè°ƒç”¨forkåˆ›å»ºæ–°çš„è¿›ç¨‹ï¼Œparentè¿›ç¨‹ä¼šç›´æ¥æ‘¸é±¼è¿”å›ï¼Œè€Œchildè¿›ç¨‹å°±è¦è°ƒç”¨execvpè¿›å…¥ç›®æ ‡ç¨‹åºï¼Œé¡ºä¾¿è¿›å…¥zsim.cppçš„mainå‡½æ•°ã€‚

è¿™ä¸ªæ—¶å€™parentè¿›ç¨‹å°±ä¼šå¼€å§‹æ‘¸é±¼ï¼Œç­‰å¾…å­è¿›ç¨‹ç»“æŸã€‚ä½œä¸ºå¤–éƒ¨è§‚å¯Ÿè€…ï¼Œç›‘æ§æ¨¡æ‹Ÿæ˜¯å¦â€œå¡ä½â€ã€‚wait() æ‰€æœ‰é€€å‡ºçš„å­è¿›ç¨‹ï¼Œé˜²æ­¢å®ƒä»¬å˜â€œåƒµå°¸â€ã€‚å®šæœŸæ‰“å°å¿ƒè·³ï¼Œå¹¶åœ¨æ¨¡æ‹Ÿå™¨å´©æºƒæ—¶æä¾›ä¸€äº›çº¿ç´¢ã€‚

### zinfo

**GlobSimInfo**æ˜¯ä¸€ä¸ªåŸºäºå…±äº«å†…å­˜çš„è¿›ç¨‹é—´çŠ¶æ€ç®¡ç†ç±»ã€‚

### libzsim.so

è¿›å…¥åˆ°libzsim.soåï¼Œå°†æ‰§è¡Œzsim.cppçš„mainå‡½æ•°ã€‚

é¦–å…ˆæ‰§è¡Œäº†PIN_InitSymbolså’ŒPIN_Initï¼Œåˆå§‹åŒ–PINã€‚ç„¶åè°ƒç”¨PIN_AddInternalExceptionHandlerè®¾ç½®InternalExceptionHandlerå‡½æ•°ä¸ºå¼‚å¸¸handlerï¼Œæœ¬è´¨ä¸Šå°±æ˜¯backtraceç„¶åç»“æŸè¿›ç¨‹ã€‚

ç„¶åä¼šè·å–ç›®å‰å±äºç¬¬å‡ ä¸ªè¿›ç¨‹ï¼Œå¦‚æœæ˜¯ç¬¬0ä¸ªè¿›ç¨‹ï¼Œå°±å¼€å§‹æ‰§è¡ŒSimInitå‡½æ•°ã€‚

#### SimInit

SimInitå‡½æ•°ä¼šåˆå§‹åŒ–zinfoï¼Œé…ç½®å¥½ä»¿çœŸçš„æ ¸å¿ƒæ•°ï¼Œè®¾ç½®å¥½sim.domainsã€sim.contentionThreadsç­‰é€‰é¡¹ï¼Œåˆå§‹åŒ–**ContentionSim**ç±»ï¼Œ

ç„¶åé…ç½®sim.phaseLengthã€sim.statsPhaseIntervalã€sys.frequencyç­‰ã€‚

ç„¶ååˆå§‹åŒ–ä¸€ä¸ª**EventQueue**ç±»ï¼Œå¦‚æœæ²¡æœ‰è¢«é…ç½®æˆtraceDrivenæ¨¡å¼ï¼Œé‚£ä¹ˆå°±åˆå§‹åŒ–**Scheduler**ç±»ã€‚

è°ƒç”¨InitGlobalStatsåˆå§‹åŒ–å…¨å±€çŠ¶æ€ã€‚

åˆå§‹åŒ–**AggregateStat**ç±»ï¼Œåˆå§‹åŒ–**PortVirtualizer**ç±»ã€‚

ç„¶åè°ƒç”¨CreateProcessTreeåˆ›å»ºè¿›ç¨‹æ ‘ã€‚è°ƒç”¨InitNUMAè®¾ç½®å’ŒéªŒè¯NUMAæ¨¡æ‹Ÿç¯å¢ƒï¼Œç„¶ååˆ›å»º**NUMAMap**ç±»ã€‚

è°ƒç”¨InitSystemåˆå§‹åŒ–cacheã€coreå’Œmemory controllerã€‚ä¼šæŠŠè¿™äº›çš„hierarchyç»„åˆæˆä¸€ä¸ªmapå’Œparentã€childçš„å…³ç³»ï¼ŒInitSystem å‡½æ•° new å‡ºäº†ä¸€ç³»åˆ—æ ¸å¿ƒç±»ï¼Œä¸»è¦åŒ…æ‹¬ï¼šSimpleCoreã€TimingCore æˆ– OOOCoreï¼ˆCPU æ ¸å¿ƒï¼‰ï¼ŒBaseCache çš„å„ç§å­ç±»ï¼ˆç¼“å­˜ï¼‰ï¼ŒMemInterconnectã€MemRouter å’Œ MemInterconnectInterfaceï¼ˆæ€»çº¿/äº’è¿ï¼‰ï¼Œä»¥åŠ BuildMemoryController è¿”å›çš„ MemObjectï¼ˆå†…å­˜æ¡ï¼‰ã€‚è¿™äº› new å¥½çš„å¯¹è±¡å¹¶æ²¡æœ‰ä¸€ä¸ªç»Ÿä¸€çš„â€œå…¨å±€åˆ—è¡¨â€ï¼›ç›¸åï¼Œå®ƒä»¬é€šè¿‡ setParents() å’Œ setChildren() æ–¹æ³•è¢«â€œç„Šæ¥â€åœ¨äº†ä¸€èµ·ã€‚æœ€ç»ˆï¼Œæ‰€æœ‰çš„ CPU æ ¸å¿ƒ æŒ‡é’ˆè¢«å­˜æ”¾åœ¨å…¨å±€çš„ zinfo->cores æ•°ç»„ä¸­ï¼Œè€Œç¼“å­˜ã€æ€»çº¿å’Œå†…å­˜åˆ™é€šè¿‡å½¼æ­¤çš„çˆ¶/å­æŒ‡é’ˆï¼Œæ„æˆäº†ä¸€ä¸ªä»æ ¸å¿ƒï¼ˆCoreï¼‰ç›´è¾¾å†…å­˜ï¼ˆMemoryï¼‰çš„å®Œæ•´ã€å¯éå†çš„å±‚çº§æ ‘ã€‚

å¦‚æœå®šä¹‰äº†ï¼Œå°±æ‰§è¡Œzinfo->sched->initStatsã€‚new **ProcessStats**ç±»ï¼Œnew **ProcStats**ç±»ï¼Œnew **VectorCounter**ç±»ä½œä¸ºzinfo->profHeartbeatsçš„å€¼ï¼Œå¤„ç†ä¸€äº›æ‚é¡¹åæ‰§è¡Œzinfo->contentionSim->postInitï¼Œå¹¶è®¾ç½®gm_set_glob_ptr(zinfo)ï¼Œå³å®ŒæˆSimInitã€‚

SimInitè°ƒç”¨ç»“æŸåï¼Œåˆå§‹åŒ–fPtrså’Œcidsã€‚fPtrsæ˜¯æ‰€æœ‰ä»¿çœŸthreadçš„å‡½æ•°æŒ‡é’ˆé›†åˆã€‚æ¯ä¸€ä¸ªthreadå¯¹åº”äº†è‡ªå·±çš„loadPtrã€storePtrã€bblPtrã€branchPtrã€predLoadPtrã€predStorePtrï¼Œè¿™äº›æ˜¯zsimä¸­å¯¹ä¸åŒä»¿çœŸæ•°æ®çš„å¤„ç†å‡½æ•°ã€‚cidsæ˜¯ç‰©ç†ä¸Šçš„æ ‡è¯†ç¬¦ï¼Œæ ‡è¯†ä»£è¡¨zsimæ¨¡æ‹Ÿçš„ç¡¬ä»¶CPUæ ¸å¿ƒï¼ˆcoreï¼‰ã€‚tid(Thread ID): é€»è¾‘æ ‡è¯†ç¬¦ã€‚ä»£è¡¨æ­£åœ¨æ¨¡æ‹Ÿçš„åº”ç”¨ç¨‹åºä¸­çš„çº¿ç¨‹ã€‚zsimä¸­è¿˜æœ‰ä¸€ä¸ªgidï¼Œå°±æ˜¯ä¸€ä¸ª32ä½çš„æ•´æ•°ï¼Œå®ƒçš„é«˜16ä½æ˜¯pidï¼Œä½16ä½æ˜¯tidã€‚

ç„¶åå¼€å§‹è°ƒç”¨VirtCaptureClocksè®¾ç½®è™šæ‹ŸåŒ–çš„**ClockDomainInfo**ç±»ã€‚

#### FFIInit

ç„¶åè°ƒç”¨FFIInitå‡½æ•°åœ¨è¿›ç¨‹startæ—¶åˆå§‹åŒ–Fast-Forward Intervalsã€‚è¿™ä¸ªå‡½æ•°è¯»å–ffiPointsåˆ—è¡¨ï¼ˆä¾‹å¦‚ [1M, 9M]ï¼‰ã€‚è®¾ç½®ç¬¬ä¸€ä¸ªæŒ‡ä»¤é™åˆ¶ ffiInstrsLimit = 1000000ã€‚æ­¤æ—¶ï¼Œæ¨¡æ‹Ÿå™¨å¤„äºNFF (è¯¦ç»†æ¨¡æ‹Ÿ) æ¨¡å¼ã€‚

è°ƒç”¨FFITrackNFFInterval()ã€‚è¿™ä¸ªå‡½æ•°â€œè®¾ç½®ä¸€ä¸ªé—¹é’Ÿâ€ã€‚å®ƒä½¿ç”¨makeAdaptiveEventåˆ›å»ºä¸€ä¸ªäº‹ä»¶ï¼Œæ’å…¥åˆ°zinfo->eventQueueä¸­ã€‚è¿™ä¸ªäº‹ä»¶å°†åœ¨ ffiInstrsLimitè¿™ä¹ˆå¤šï¼ˆå³100ä¸‡æ¡ï¼‰è¯¦ç»†æŒ‡ä»¤è¢«æ‰§è¡Œåè§¦å‘ã€‚è§¦å‘çš„æ˜¯ffiFire lambda(åˆ‡æ¢åˆ° FF)ï¼šå½“è¿™100ä¸‡æ¡è¯¦ç»†æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•ï¼Œ"é—¹é’Ÿ"å“èµ·ï¼ŒffiFireè¿™ä¸ªlambdaåŒ¿åå‡½æ•°è¢«æ‰§è¡Œã€‚å®ƒæ‰“å° "Entering fast-forward" å¹¶è°ƒç”¨ zinfo->procArray[p]->enterFastForward()ã€‚æ¨¡æ‹Ÿå™¨åˆ‡æ¢åˆ°FF(å¿«è¿›)æ¨¡å¼ã€‚FFIEntryBasicBlockä½œä¸ºè¿‡æ¸¡å‡½æ•°è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œå®ƒä¼šè°ƒç”¨FFIAdvance()ã€‚

ç„¶åæ‰§è¡ŒVirtInitå‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¸»è¦å°±æ˜¯patchç³»ç»Ÿè°ƒç”¨ï¼Œpatchäº†ä»¥ä¸‹éƒ¨åˆ†ï¼š

#### VirtInit

åˆå§‹åŒ–zsimçš„ç³»ç»Ÿè°ƒç”¨è™šæ‹ŸåŒ–åŠŸèƒ½ã€‚

1. ğŸ“ æ–‡ä»¶ç³»ç»Ÿ (fs.cpp) Syscalls: SYS_open, SYS_openatã€‚ç”¨é€”ï¼š æ‹¦æˆªæ–‡ä»¶æ‰“å¼€è¯·æ±‚ã€‚è¿™æ˜¯ä¸ºäº†æä¾›ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ˆpatchRootï¼‰ã€‚å½“ç¨‹åºå°è¯•è¯»å– /sys/devices/system/nodeï¼ˆNUMA æ‹“æ‰‘ï¼‰æˆ– /proc/cpuinfoï¼ˆCPU ä¿¡æ¯ï¼‰æ—¶ï¼Œzsim ä¼šæ‹¦æˆªè¿™ä¸ªè¯·æ±‚ï¼Œå¹¶ç»™å®ƒè¿”å›ä¸€ä¸ªä¼ªé€ çš„ã€æè¿°æ¨¡æ‹Ÿç³»ç»Ÿæ‹“æ‰‘çš„æ–‡ä»¶ã€‚

2. ğŸŒ ç«¯å£/ç½‘ç»œ (ports.cpp) Syscalls: SYS_bind, SYS_getsockname, SYS_connectã€‚ç”¨é€”ï¼š è™šæ‹ŸåŒ–ç½‘ç»œç«¯å£ã€‚è¿™å…è®¸å¤šä¸ª zsim æ¨¡æ‹Ÿçš„è¿›ç¨‹åœ¨æ¨¡æ‹Ÿçš„ç½‘ç»œä¸Šäº’ç›¸é€šä¿¡ï¼Œè€Œä¸ä¼šå ç”¨æˆ–å¹²æ‰°å®¿ä¸»æœºçš„çœŸå®ç½‘ç»œç«¯å£ã€‚

3. ğŸ–¥ï¸ CPU è™šæ‹ŸåŒ– (cpu.cpp) Syscalls: SYS_getcpu, SYS_sched_getaffinity, SYS_sched_setaffinityã€‚ç”¨é€”ï¼š å‘ç¨‹åºâ€œè°æŠ¥â€CPU ä¿¡æ¯ã€‚å½“ç¨‹åºè¯¢é—®â€œæˆ‘åœ¨å“ªä¸ªCPUä¸Šè¿è¡Œï¼Ÿâ€ï¼ˆgetcpuï¼‰æˆ–â€œæˆ‘å…è®¸åœ¨å“ªäº›CPUä¸Šè¿è¡Œï¼Ÿâ€ï¼ˆgetaffinityï¼‰æ—¶ï¼Œzsim ä¼šæ‹¦æˆªå®ƒï¼Œå¹¶æ ¹æ® Scheduler çš„è°ƒåº¦ï¼ˆgid -> cid çš„æ˜ å°„ï¼‰è¿”å›æ¨¡æ‹Ÿçš„ CPU æ ¸å¿ƒ IDï¼ˆcidï¼‰ï¼Œè€Œä¸æ˜¯å®¿ä¸»æœºçš„ CPU IDã€‚

4. ğŸ§  NUMA è™šæ‹ŸåŒ– (numa.cpp) Syscalls: SYS_get_mempolicy, SYS_set_mempolicy, SYS_mbind, SYS_munmap, SYS_mremap ç­‰ã€‚ç”¨é€”ï¼š è¿™æ˜¯ NUMAMap æœºåˆ¶çš„æ ¸å¿ƒã€‚zsim å¿…é¡»æ‹¦æˆªæ‰€æœ‰ç®¡ç†å†…å­˜ç­–ç•¥çš„è°ƒç”¨ã€‚set_mempolicy: å½“ç¨‹åºè®¾ç½®å†…å­˜ç­–ç•¥ï¼ˆå¦‚â€œæœ¬åœ°ä¼˜å…ˆâ€æˆ–â€œäº¤é”™â€ï¼‰æ—¶ï¼Œzsim æ‹¦æˆªå®ƒï¼Œå¹¶å°†è¿™ä¸ªç­–ç•¥ä¿å­˜åˆ° NUMAMap çš„ threadPolicy ä¸­ã€‚munmap: å½“ç¨‹åºé‡Šæ”¾å†…å­˜æ—¶ï¼Œzsim æ‹¦æˆªå®ƒï¼Œä»¥ä¾¿æ›´æ–° NUMAMap ä¸­çš„ PageMapï¼ˆé¡µ -> èŠ‚ç‚¹ï¼‰æ˜ å°„ã€‚

5. ğŸ›‘ çº¿ç¨‹æ§åˆ¶ (control.cpp) Syscalls: SYS_exit_groupã€‚ç”¨é€”ï¼š ä¼˜é›…åœ°ç»ˆæ­¢æ¨¡æ‹Ÿã€‚å½“è¢«æ¨¡æ‹Ÿçš„ç¨‹åºï¼ˆçš„ä¸»çº¿ç¨‹ï¼‰é€€å‡ºæ—¶ï¼Œzsim å¿…é¡»æ•è·è¿™ä¸ªäº‹ä»¶ï¼Œä»¥ä¾¿åœæ­¢æ‰€æœ‰æ¨¡æ‹Ÿç»„ä»¶ã€åˆ·æ–°æ‰€æœ‰ç»Ÿè®¡æ•°æ®å¹¶å¹²å‡€åœ°é€€å‡ºï¼Œè€Œä¸æ˜¯è®©æ•´ä¸ª Pin å·¥å…·å´©æºƒã€‚

6. â° æ—¶é—´ä¸è¶…æ—¶ (time.cpp, timeout.cpp) Syscalls: SYS_gettimeofday, SYS_time, SYS_nanosleep, SYS_futex, SYS_poll ç­‰ã€‚ç”¨é€”ï¼š æ—¶é—´è™šæ‹ŸåŒ–ã€‚è¿™æ˜¯æ¨¡æ‹Ÿå™¨æœ€å…³é”®çš„è¡¥ä¸ä¹‹ä¸€ã€‚è·å–æ—¶é—´ï¼š å½“ç¨‹åºè¯¢é—®â€œç°åœ¨å‡ ç‚¹äº†ï¼Ÿâ€ï¼ˆgettimeofdayï¼‰ï¼Œzsim ä¼šè¿”å›æ¨¡æ‹Ÿæ—¶é—´ï¼ˆå³ zinfo->globPhaseCyclesï¼‰ï¼Œè€Œä¸æ˜¯çœŸå®çš„æŒ‚é’Ÿæ—¶é—´ã€‚é˜»å¡/ç¡çœ ï¼š å½“ç¨‹åºè°ƒç”¨ nanosleep æˆ– futexï¼ˆç­‰å¾…é”ï¼‰æ—¶ï¼Œå®ƒæœ¬æ„æ˜¯â€œé˜»å¡â€è‡ªå·±ã€‚å¦‚æœ zsim è®©å®¿ä¸»æœº OS çœŸçš„é˜»å¡å®ƒï¼Œæ•´ä¸ªæ¨¡æ‹Ÿéƒ½ä¼šå¡ä½ã€‚zsim ä¼šæ‹¦æˆªè¿™ä¸ªè°ƒç”¨ï¼Œåœ¨ Scheduler ä¸­å°†è¯¥çº¿ç¨‹è®¾ä¸º SLEEPING æˆ– BLOCKED çŠ¶æ€ï¼Œç„¶åç»§ç»­æ¨è¿›æ¨¡æ‹Ÿæ—¶é—´ï¼Œç›´åˆ°æ»¡è¶³å”¤é†’æ¡ä»¶ã€‚

#### VdsoInit

åœ¨è°ƒç”¨å®ŒVirtInitå‡½æ•°åï¼Œå°±ä¼šå¼€å§‹è°ƒç”¨VdsoInitå‡½æ•°ã€‚VirtInit è´Ÿè´£æ‹¦æˆªæ™®é€šçš„ç³»ç»Ÿè°ƒç”¨ï¼ˆé‚£äº›ä¼šé™·å…¥å†…æ ¸çš„ï¼‰ï¼Œè€Œ VdsoInit è´Ÿè´£æ‹¦æˆªèµ°æ·å¾„çš„ç³»ç»Ÿè°ƒç”¨ï¼ˆé‚£äº›å®Œå…¨åœ¨ç”¨æˆ·æ€å®Œæˆçš„ï¼‰ã€‚ä¸»è¦é’ˆå¯¹clock_gettimeã€gettimeofdayã€timeã€getcpuã€‚

#### æ’æ¡©

åœ¨åˆå§‹åŒ–å®Œè™šæ‹ŸåŒ–åï¼Œå°±è¦è¿›è¡Œæ’æ¡©äº†ï¼Œæ’æ¡©çš„éƒ¨åˆ†å¦‚ä¸‹ï¼š

1. æ ¸å¿ƒæŒ‡ä»¤æµæ’æ¡©ã€‚ä½¿ç”¨TRACE_AddInstrumentFunctionå‡½æ•°ï¼Œæ¯å½“ Pin å‘ç°ä¸€ä¸ªæ–°çš„ Traceï¼Œå®ƒå°±ä¼šè°ƒç”¨ zsim çš„ Trace() å‡½æ•°ã€‚
2. çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ä½¿ç”¨PIN_AddThreadStartFunctionå‡½æ•°å’ŒPIN_AddThreadFiniFunctionå‡½æ•°ã€‚å½“ç›®æ ‡ç¨‹åº pthread_create æ—¶ï¼Œzsim éœ€è¦åœ¨è‡ªå·±çš„ Scheduler ä¸­æ³¨å†Œè¿™ä¸ªæ–°çº¿ç¨‹ï¼Œåˆ†é…ä¸€ä¸ª ThreadInfoï¼Œå¹¶ç»™å®ƒåˆ†é…ä¸€ä¸ªæ¨¡æ‹Ÿæ ¸å¿ƒ (cid)ã€‚Fini: å½“çº¿ç¨‹é€€å‡ºæ—¶ï¼Œzsim éœ€è¦å›æ”¶èµ„æºï¼Œå¹¶åœ¨ Scheduler ä¸­æ³¨é”€å®ƒã€‚å®ç°çš„å‡½æ•°æ˜¯ThreadStartå’ŒThreadFiniã€‚
3. ç³»ç»Ÿè°ƒç”¨æ‹¦æˆªã€‚ä½¿ç”¨PIN_AddSyscallEntryFunctionå‡½æ•°å’ŒPIN_AddSyscallExitFunctionå‡½æ•°ã€‚è°ƒç”¨çš„å‡½æ•°ä¸ºSyscallEnterå’ŒSyscallExitã€‚ä½¿ç”¨PIN_AddContextChangeFunctionå‡½æ•°å½“å‘ç”Ÿéæ­£å¸¸çš„æ§åˆ¶æµæ”¹å˜ï¼ˆä¸»è¦æ˜¯ä¿¡å· Signal å¤„ç†ï¼‰æ—¶è°ƒç”¨ContextChangeå‡½æ•°ã€‚
4. è¿›ç¨‹ä¸å¤šä»»åŠ¡ã€‚ä½¿ç”¨PIN_AddFiniFunctionå‡½æ•°åœ¨ç›®æ ‡ç¨‹åºå½»åº•ç»“æŸï¼ˆexitï¼‰æ—¶è°ƒç”¨Finiå‡½æ•°ã€‚Finiå‡½æ•°åˆä¼šæ¥ç€è°ƒç”¨SimEndå‡½æ•°æ‰§è¡ŒçœŸæ­£çš„ç»“æŸä»»åŠ¡ã€‚åŒæ—¶éœ€è¦å¤„ç†è¿›ç¨‹æ ‘çš„æ¨¡æ‹Ÿã€‚ä½¿ç”¨PIN_AddFollowChildProcessFunctionæŒ‡å®šFollowChildï¼ˆå‘Šè¯‰ Pinï¼Œå¦‚æœå½“å‰ç¨‹åºè°ƒç”¨äº† exec å¯åŠ¨æ–°ç¨‹åºï¼Œè¯·ç»§ç»­è·Ÿè¸ªæ–°ç¨‹åºï¼ŒæŠŠPinToolæ³¨å…¥è¿›å»ï¼‰ã€‚ç„¶åPIN_AddForkFunctionè®¾ç½®è°ƒç”¨BeforeForkï¼ˆèµ‹å€¼é™æ€å˜é‡forkedChildNodeä¸ºprocTreeNode->getNextChild()ï¼‰ï¼ŒAfterForkInParentï¼ˆforkedChildNodeè®¾ç½®ä¸ºnullptrï¼‰å’ŒAfterForkInChildï¼ˆè°ƒç”¨procTreeNode->notifyStart()ï¼Œè¾“å‡ºæ–°è¿›ç¨‹çš„ä¿¡æ¯ï¼Œå¹¶ä¸”åˆå§‹è¿™ä¸ªæ–°PINè¿›ç¨‹çš„fPtrsä¸ºjoinPtrsã€cidsä¸ºUNINITIALIZED_CIDï¼Œå¹¶ä¸”è®©å­è¿›ç¨‹ä¹Ÿå¼€å§‹æ‰§è¡ŒFFThreadï¼‰ã€‚ç„¶åä¸»è¿›ç¨‹çš„ä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹å¹¶æ‰§è¡ŒFFThreadå‡½æ•°ï¼Œç„¶åè‡ªå·±é€šè¿‡PIN_StartProgramå‡½æ•°ä¸å†è¿”å›ã€‚æ‰€ä»¥è¿™é‡Œå…¶å®æ¨¡æ‹Ÿå™¨ç¨‹åºæœ¬èº«æœ€ç»ˆè¿è¡Œçš„éƒ½æ˜¯FFThreadå‡½æ•°ï¼Œä¸ç®¡æ˜¯ä¸»è¿›ç¨‹è¿˜æ˜¯forkåçš„è¿›ç¨‹ï¼Œéƒ½éœ€è¦FFThreadå‡½æ•°è¿›è¡Œä»¿çœŸã€‚

### Trace

åŒºåˆ†ä¸¤ä¸ªæ—¶é—´ç‚¹ï¼š

1. æ’æ¡©æ—¶ (Instrumentation Time)ï¼šå³ Trace() å‡½æ•°æ‰§è¡Œçš„æ—¶å€™ã€‚è¿™æ˜¯ Pin åœ¨å³æ—¶ç¼–è¯‘ï¼ˆJITï¼‰ä»£ç ï¼Œå®ƒå†³å®šäº†â€œè¦æ’å…¥ä»€ä¹ˆä»£ç â€ã€‚

2. åˆ†æ/æ‰§è¡Œæ—¶ (Analysis/Execution Time)ï¼šå³ç›®æ ‡ç¨‹åºçœŸæ­£è¿è¡Œçš„æ—¶å€™ã€‚æ­¤æ—¶ï¼Œè¢«æ’å…¥çš„é‚£äº›å‡½æ•°ï¼ˆå¦‚ IndirectBasicBlockï¼‰æ‰ä¼šè¢«çœŸæ­£è°ƒç”¨ã€‚

#### 1. æ€»å…¥å£

å½“ Pin å‘ç°ä¸€æ®µæ–°çš„ä»£ç è½¨è¿¹ï¼ˆTraceï¼Œé€šå¸¸æ˜¯ä¸€ä¸²åŸºæœ¬å— Basic Blockï¼‰æ—¶è°ƒç”¨ã€‚å®ƒçš„ä»»åŠ¡æ˜¯éå†è¿™æ®µä»£ç ï¼Œæ’å…¥ zsim çš„å›è°ƒå‡½æ•°ã€‚

ä»£ç é¦–å…ˆéå† Trace ä¸­çš„æ¯ä¸€ä¸ªåŸºæœ¬å—ï¼ˆBBLï¼‰ã€‚å‰ææ¡ä»¶ï¼š å¦‚æœå½“å‰å¤„äºâ€œå¿«è¿›æ¨¡å¼â€(FastForward) ä¸”ä¸éœ€è¦é‡æ’æ¡©ï¼Œåˆ™è·³è¿‡æ­¤æ­¥ï¼ˆä¸ºäº†æ€§èƒ½ï¼‰ã€‚

- Decoder::decodeBbl(bbl, ...)ï¼š
    - å¹²ä»€ä¹ˆï¼šè¿™æ˜¯ä¸€ä¸ªé™æ€åˆ†æè¿‡ç¨‹ã€‚å®ƒåˆ†æè¿™ä¸ª BBL é‡Œæœ‰å¤šå°‘æŒ‡ä»¤ã€æœ‰å¤šå°‘å†…å­˜æ“ä½œã€æŒ‡ä»¤é—´çš„ä¾èµ–å…³ç³»ç­‰ã€‚
    - äº§å‡ºï¼šç”Ÿæˆä¸€ä¸ª BblInfo ç»“æ„ä½“ï¼Œé‡Œé¢åŒ…å«äº†æ¨¡æ‹Ÿè¿™ä¸ª BBL æ‰€éœ€çš„æ‰€æœ‰å…ƒæ•°æ®ï¼ˆæŒ‡ä»¤æ•°ã€å­—èŠ‚æ•°ç­‰ï¼‰ã€‚
- BBL_InsertCall(..., IndirectBasicBlock, ...)ï¼š
    - å¹²ä»€ä¹ˆï¼šåœ¨ BBL çš„å¼€å¤´æ’å…¥ä¸€ä¸ªè°ƒç”¨ã€‚
    - æ’å…¥äº†è°ï¼šIndirectBasicBlockã€‚
    - å‚æ•°ï¼šä¼ å…¥äº† BblInfo æŒ‡é’ˆã€‚
    - æ„ä¹‰ï¼šå½“ç¨‹åºè¿è¡Œåˆ°è¿™ä¸ªåŸºæœ¬å—æ—¶ï¼Œzsim ä¼šå…ˆè·å¾—æ§åˆ¶æƒï¼Œæ‹¿åˆ°è¿™ä¸ªå—çš„å…ƒæ•°æ®ï¼Œç„¶åç®—å‡ºè¿™ä¸ªå—æ¶ˆè€—äº†å¤šå°‘å‘¨æœŸï¼ˆCycleï¼‰ï¼Œæ¨è¿›æ¨¡æ‹Ÿæ—¶é—´ã€‚

#### 2. æŒ‡ä»¤ (Instruction) çº§æ’æ¡©

æ¥ç€ï¼Œä»£ç å†æ¬¡éå† BBLï¼Œå¹¶æ·±å…¥éå†å…¶ä¸­çš„æ¯ä¸€æ¡æŒ‡ä»¤ï¼ˆINSï¼‰ã€‚è°ƒç”¨ï¼šInstruction(ins)ã€‚èŒè´£ï¼šå†³å®šå¯¹å½“å‰è¿™æ¡å…·ä½“çš„æŒ‡ä»¤â€œåšç‚¹ä»€ä¹ˆâ€ã€‚

- å†…å­˜è®¿é—®æ’æ¡© (Memory Access)
    - åˆ¤æ–­ï¼šé€šè¿‡ INS_IsMemoryRead / INS_IsMemoryWrite æ£€æŸ¥æŒ‡ä»¤æ˜¯å¦è¯»å†™å†…å­˜ã€‚
    - æ’å…¥ï¼š
        - å¦‚æœæ˜¯è¯»ï¼šæ’å…¥ IndirectLoadSingleã€‚
        - å¦‚æœæ˜¯å†™ï¼šæ’å…¥ IndirectStoreSingleã€‚
    - å‚æ•°ï¼šä¼ å…¥ IARG_MEMORYREAD_EA (æœ‰æ•ˆåœ°å€)ã€‚
    - æ„ä¹‰ï¼šè¿™æ˜¯ Cache æ¨¡æ‹Ÿçš„åŸºç¡€ã€‚zsim éœ€è¦æ‹¦æˆªæ¯ä¸€æ¬¡å†…å­˜è®¿é—®çš„åœ°å€ï¼Œæ‰”ç»™ Cache å±‚æ¬¡ç»“æ„å»åˆ¤æ–­æ˜¯ Hit è¿˜æ˜¯ Missã€‚
- åˆ†æ”¯é¢„æµ‹æ’æ¡© (Branch Prediction)
    - åˆ¤æ–­ï¼šINS_Category(ins) == XED_CATEGORY_COND_BRï¼ˆæ¡ä»¶è·³è½¬ï¼‰ã€‚
    - æ’å…¥ï¼šIndirectRecordBranchã€‚
    - æ„ä¹‰ï¼šå°†åˆ†æ”¯çš„è·³è½¬æ–¹å‘ï¼ˆTaken/Not Takenï¼‰å’Œç›®æ ‡åœ°å€ä¼ ç»™ CPU æ¨¡å‹çš„åˆ†æ”¯é¢„æµ‹å™¨ (Branch Predictor)ï¼Œç”¨æ¥æ›´æ–°é¢„æµ‹å†å²å¹¶è®¡ç®—é¢„æµ‹å¤±è´¥çš„æƒ©ç½šã€‚

##### è™šæ‹ŸåŒ–ä¸é­”æ³•æŒ‡ä»¤ (Virtualization & Magic)

è¿™æ˜¯ zsim èƒ½å¤Ÿâ€œæ¬ºéª—â€ç›®æ ‡ç¨‹åºçš„å…³é”®ã€‚

- Magic Ops (xchg %rcx, %rcx)ï¼š
    - æ’å…¥ï¼šHandleMagicOpã€‚
    - åŠŸèƒ½ï¼šè¿™æ˜¯ä¸€ä¸ªâ€œåé—¨â€ã€‚è¢«æ¨¡æ‹Ÿçš„ç¨‹åºå¯ä»¥é€šè¿‡è¿™æ¡ç‰¹æ®Šçš„æ±‡ç¼–æŒ‡ä»¤å‘Šè¯‰ zsimï¼šâ€œå¼€å§‹æ„Ÿå…´è¶£åŒºåŸŸ(ROI)â€ã€â€œå¿ƒè·³â€ã€â€œæ³¨å†Œçº¿ç¨‹â€ç­‰ã€‚è¿™å®ç°äº† Guest å’Œ Host çš„é€šä¿¡ã€‚
- CPUID (FakeCPUIDPre/Post)ï¼š
    - æ’å…¥ï¼šåœ¨ CPUID æŒ‡ä»¤çš„å‰åæ’å…¥ã€‚
    - åŠŸèƒ½ï¼šCPUID æŒ‡ä»¤é€šå¸¸è¿”å›å®¿ä¸»æœºçš„ CPU ä¿¡æ¯ã€‚zsim å¿…é¡»æ‹¦æˆªå®ƒï¼Œç¯¡æ”¹å¯„å­˜å™¨ï¼ˆEAX, EBX ç­‰ï¼‰çš„å€¼ï¼Œè®©ç¨‹åºä»¥ä¸ºè‡ªå·±è¿è¡Œåœ¨ zsim é…ç½®çš„é‚£ä¸ª 64 æ ¸ CPU ä¸Šï¼Œè€Œä¸æ˜¯ä½ çš„ç¬”è®°æœ¬ç”µè„‘ä¸Šã€‚ä»£ç ä¸­å¯ä»¥çœ‹åˆ°å®ƒè®¡ç®— apicId å’Œ siblings çš„é€»è¾‘ã€‚
- RDTSC (FakeRDTSCPost)ï¼š
    - æ’å…¥ï¼šåœ¨ RDTSC æŒ‡ä»¤åæ’å…¥ã€‚
    - åŠŸèƒ½ï¼šRDTSC è¯»å–ç¡¬ä»¶çš„æ—¶é—´æˆ³è®¡æ•°å™¨ã€‚zsim å¿…é¡»æ‹¦æˆªå¹¶è¦†ç›–å®ƒçš„è¿”å›å€¼ï¼ˆEAX:EDXï¼‰ï¼Œå¡«å…¥ zinfo->globPhaseCyclesï¼ˆæ¨¡æ‹Ÿæ—¶é—´ï¼‰ã€‚å¦‚æœè¿™é‡Œä¸æ‹¦æˆªï¼Œç¨‹åºè¯»åˆ°çš„æ˜¯çœŸå®ä¸–ç•Œçš„é£å¿«æµé€çš„æ—¶é—´ï¼Œæ¨¡æ‹Ÿç»“æœå°±ä¼šå®Œå…¨é”™è¯¯ï¼ˆTime Leakageï¼‰ã€‚

#### 3. Indirect... ç³»åˆ—å‡½æ•°ä¸ fPtrsï¼šå¤šæ€çš„å®ç°

fPtrs (Function Pointers)ï¼šè¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªçº¿ç¨‹ (tid) å¯¹åº”ä¸€ä¸ª InstrFuncPtrs ç»“æ„ä½“ï¼Œé‡Œé¢å­˜ç€ loadPtr, storePtr, bblPtr ç­‰å‡½æ•°æŒ‡é’ˆã€‚

- å½“çº¿ç¨‹å¤„äº Detailed Simulation (NFF) æ¨¡å¼æ—¶ï¼ŒfPtrs[tid] æŒ‡å‘çœŸæ­£çš„æ¨¡æ‹Ÿå‡½æ•°ï¼ˆå¦‚ SimLoadï¼‰ã€‚
- å½“çº¿ç¨‹å¤„äº Fast Forward (FF) æ¨¡å¼æ—¶ï¼ŒfPtrs[tid] æŒ‡å‘ç©ºå‡½æ•°ï¼ˆNopLoadï¼‰ã€‚
- å½“çº¿ç¨‹å¤„äº Null/Blocked çŠ¶æ€æ—¶ï¼Œå®ƒæŒ‡å‘å¦ä¸€ç»„å‡½æ•°ã€‚

### FFThread

è¿™ä¸ªæœºåˆ¶çš„è®¾è®¡åˆè¡·æ˜¯ä¸ºäº†è§£å†³ Intel Pin åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¤„ç†ä¿¡å·ï¼ˆSignalï¼‰ä¸ç¨³å®šçš„é—®é¢˜ï¼Œå› æ­¤ä½œè€…é€‰æ‹©äº†ä¸€ä¸ªâ€œç¬¨åŠæ³•â€ï¼šç”¨ä¸€ä¸ªçº¿ç¨‹æ­»å¾ªç¯ç­‰å¾…å¤–éƒ¨è§¦å‘ã€‚

1. FFThread çš„æ ¸å¿ƒé€»è¾‘ï¼šæ— é™ç­‰å¾…å¾ªç¯
    - è§’è‰²ï¼šè¿™æ˜¯ä¸€ä¸ªâ€œå®ˆæŠ¤çº¿ç¨‹â€ï¼Œå®ƒä¸å‚ä¸æ¨¡æ‹Ÿï¼Œåªè´Ÿè´£ç›‘å¬å¼€å…³è¯·æ±‚ã€‚
    - å¯åŠ¨ï¼šåœ¨ main å‡½æ•°ä¸­é€šè¿‡ PIN_SpawnInternalThread å¯åŠ¨ã€‚
        1. åˆå§‹åŒ–é”ï¼šffToggleLocks æ˜¯é€šä¿¡çš„åª’ä»‹ã€‚çº¿ç¨‹å…ˆé”ä½å®ƒï¼Œç„¶åè¯•å›¾å†æ¬¡åŠ é”ï¼ˆè§ä¸‹æ–‡ï¼‰ï¼Œè¿™æ ·å®ƒå°±ä¼šé˜»å¡ã€‚å¤–éƒ¨è§¦å‘å™¨ï¼ˆä¾‹å¦‚å¦ä¸€ä¸ªå·¥å…· fftoggleï¼‰é€šè¿‡è§£é” (unlock) è¿™ä¸ª mutex æ¥â€œæ…â€ä¸€ä¸‹ zsimï¼Œå‘Šè¯‰å®ƒâ€œè¯¥åˆ‡æ¢æ¨¡å¼äº†â€ã€‚
        2. è¿›å…¥å¾ªç¯ç­‰å¾…è§¦å‘ã€‚`bool locked = futex_trylock_nospin_timeout(..., 5*BILLION);`ï¼Œçº¿ç¨‹åœ¨è¿™é‡Œé˜»å¡ã€‚å®ƒå°è¯•å»é”é‚£ä¸ªå·²ç»è¢«è‡ªå·±é”ä½çš„é”ï¼ˆæˆ–è€…ç­‰å¾…åˆ«äººè§£é”å®ƒï¼‰ã€‚è¶…æ—¶æœºåˆ¶ (5ç§’)ï¼šå®ƒæ¯ 5 ç§’é†’æ¥ä¸€æ¬¡ï¼Œä¸æ˜¯ä¸ºäº†åˆ‡æ¢ï¼Œè€Œæ˜¯æ£€æŸ¥ zinfo->terminationConditionMetï¼ˆæ¨¡æ‹Ÿæ˜¯å¦ç»“æŸäº†ï¼Ÿï¼‰ï¼Œä»¥ä¾¿ä¼˜é›…é€€å‡ºã€‚è¢«å”¤é†’ï¼šå¦‚æœ locked == trueï¼Œè¯´æ˜æœ‰äººåœ¨å¤–é¢è§£å¼€äº†è¿™æŠŠé”ã€‚è¿™æ„å‘³ç€æ”¶åˆ°äº†åˆ‡æ¢ä¿¡å·ã€‚
        3. å¤„ç†åˆ‡æ¢è¯·æ±‚ã€‚æ‹¿åˆ°å…¨å±€é” zinfo->ffLock ä¿æŠ¤çŠ¶æ€ã€‚åˆ¤æ–­å½“å‰çŠ¶æ€ï¼šæƒ…å†µ Aï¼šæ­£åœ¨å¿«è¿› (FF) -> åˆ‡å›è¯¦ç»†æ¨¡æ‹Ÿã€‚æƒ…å†µ Bï¼šæ­£åœ¨è¯¦ç»†æ¨¡æ‹Ÿ (NFF) -> åˆ‡å…¥å¿«è¿›ã€‚
2. é€€å‡ºå¿«è¿› (ExitFastForward) - "ç®€å•æ¨¡å¼"
    - å¦‚æœå½“å‰æ˜¯å¿«è¿›æ¨¡å¼ï¼Œåˆ‡æ¢å›è¯¦ç»†æ¨¡æ‹Ÿæ˜¯æ¯”è¾ƒå®‰å…¨çš„ï¼Œå¯ä»¥ç«‹å³æ‰§è¡Œã€‚
    - è°ƒç”¨ ExitFastForward()
        1. VirtCaptureClocks(true)ï¼šå› ä¸ºå¿«è¿›æ—¶ä½¿ç”¨çš„æ˜¯â€œå‡â€æ—¶é—´ï¼Œåˆ‡å›è¯¦ç»†æ¨¡æ‹Ÿå‰ï¼Œå¿…é¡»æŠŠè™šæ‹Ÿæ—¶é—´ï¼ˆTSC/Cycleï¼‰åŒæ­¥å¯¹é½ï¼Œç¡®ä¿æ¨¡æ‹Ÿçš„æ—¶é—´è¿ç»­æ€§ã€‚
        2. procTreeNode->exitFastForward()ï¼šä¿®æ”¹å†…å­˜ä¸­çš„çŠ¶æ€æ ‡å¿— inFastForward = falseã€‚åŸå­æ›´æ–°å…¨å±€è®¡æ•°å™¨ã€‚
        3. __sync_synchronize()ï¼šå†…å­˜å±éšœï¼Œç¡®ä¿æ ‡å¿—ä½å˜åŒ–å¯¹æ‰€æœ‰çº¿ç¨‹å¯è§ã€‚
        4. PIN_RemoveInstrumentation() (å¦‚æœé…ç½®äº† ffReinstrument)ï¼š è¿™ä¼šå‘Šè¯‰ Pinï¼šâ€œä¸¢å¼ƒå½“å‰æ‰€æœ‰çš„ JIT ä»£ç ç¼“å­˜â€ã€‚åæœï¼šPin è¢«è¿«é‡æ–°æ’æ¡©ã€‚æ­¤æ—¶ inFastForward å˜æˆäº† falseï¼Œæ‰€ä»¥å†æ¬¡è°ƒç”¨ Trace() å‡½æ•°æ—¶ï¼Œä¼šæ’å…¥ IndirectBasicBlock å’Œ Load/Store çš„å›è°ƒï¼Œä»è€Œå¼€å¯è¯¦ç»†æ¨¡æ‹Ÿã€‚
3. è¿›å…¥å¿«è¿› (EnterFastForward) - "å›°éš¾æ¨¡å¼"
    - å¦‚æœå½“å‰æ­£åœ¨è¿›è¡Œè¯¦ç»†æ¨¡æ‹Ÿï¼Œæˆ‘ä»¬ä¸èƒ½ç«‹å³åˆ‡æ¢ã€‚å› ä¸ºæ¨¡æ‹Ÿå™¨æ˜¯ä»¥ Phase (é˜¶æ®µ) ä¸ºå•ä½è¿è¡Œçš„ï¼ˆä¾‹å¦‚æ¯ 10000 ä¸ªå‘¨æœŸåŒæ­¥ä¸€æ¬¡ï¼‰ã€‚å¦‚æœåœ¨é˜¶æ®µä¸­é—´çªç„¶åˆ‡æ–­è¯¦ç»†æ¨¡æ‹Ÿï¼Œä¼šå¯¼è‡´ä¸åŒæ ¸å¿ƒçš„æ—¶é—´ä¸åŒæ­¥ã€‚å› æ­¤ï¼ŒFFThread å¿…é¡»ç­‰å¾…å½“å‰ Phase ç»“æŸã€‚
    - è°ƒç”¨é“¾ä¸æ¡æ‰‹æµç¨‹ï¼š
        1. `zinfo->eventQueue->insert(syncEv);`,FFThread å¾€å…¨å±€äº‹ä»¶é˜Ÿåˆ—é‡Œæ‰”äº†ä¸€ä¸ª SyncEventã€‚è¿™ä¸ªäº‹ä»¶ä¼šåœ¨ä¸‹ä¸€ä¸ª Phase ç»“æŸæ—¶è¢«ä¸»æ¨¡æ‹Ÿçº¿ç¨‹å¤„ç†ã€‚
        2. `syncEv->wait();`ï¼Œé‡Šæ”¾é”å¹¶ç­‰å¾… (wait)ã€‚
        3. ä¸»æ¨¡æ‹Ÿçº¿ç¨‹ (Main Simulation Thread) çš„å·¥ä½œï¼ˆæ­¤æ—¶ FFThread åœ¨ç¡è§‰ï¼‰:
            - å®ƒè·‘å®Œå½“å‰çš„ Phaseã€‚
            - å¤„ç†äº‹ä»¶é˜Ÿåˆ—ï¼Œå–å‡º syncEvã€‚
            - è°ƒç”¨ syncEv->callback()ã€‚callback å†…éƒ¨ï¼šå”¤é†’ FFThreadï¼Œç„¶åè‡ªå·±é˜»å¡ï¼ˆç­‰å¾… FFThread å®Œæˆåˆ‡æ¢å·¥ä½œï¼‰ã€‚
        4. FFThread é†’æ¥ï¼Œé‡æ–°è·å–é”ï¼Œè°ƒç”¨ EnterFastForward()ã€‚EnterFastForward çš„å­è¿‡ç¨‹ï¼š
            1. `procTreeNode->enterFastForward()`ï¼šè®¾ç½®æ ‡å¿—ä½ inFastForward = trueã€‚
            2. `PIN_RemoveInstrumentation()`ï¼šå…³é”®ï¼ å†æ¬¡æ¸…ç©º Pin çš„ä»£ç ç¼“å­˜ã€‚
        5. `syncEv->signal();`ï¼Œé€šçŸ¥ä¸»çº¿ç¨‹ç»§ç»­ï¼Œä¸»æ¨¡æ‹Ÿçº¿ç¨‹ä» callback() ä¸­è¿”å›ï¼Œç»§ç»­æ‰§è¡Œï¼ˆæ­¤æ—¶å·²è¿›å…¥å¿«è¿›æ¨¡å¼ï¼‰ã€‚

### ThreadStart

å½“ç›®æ ‡ç¨‹åºè°ƒç”¨ pthread_create æˆ– clone æ—¶ï¼ŒPin æ•è·åˆ°è¿™ä¸€äº‹ä»¶ï¼Œå¹¶è°ƒç”¨ ThreadStartã€‚è°ƒç”¨æ—¶æœºï¼šç›®æ ‡çº¿ç¨‹åˆšåˆšè¢«æ“ä½œç³»ç»Ÿåˆ›å»ºï¼Œä½†è¿˜æ²¡æœ‰å¼€å§‹æ‰§è¡Œä»»ä½•å…·ä½“çš„åº”ç”¨ä»£ç ã€‚

1. `if (procTreeNode->isInPause()) { ... }`ï¼šå¦‚æœé…ç½®è¦æ±‚ç¨‹åºå¯åŠ¨æ—¶å…ˆâ€œæš‚åœâ€ï¼ˆç­‰å¾…å¤–éƒ¨ä¿¡å·ï¼Œæ¯”å¦‚è°ƒè¯•å™¨æˆ–å¤šè¿›ç¨‹åŒæ­¥ï¼‰ï¼Œè¿™é‡Œä¼šé˜»å¡çº¿ç¨‹ã€‚åˆ©ç”¨ futex_lock é”åŒä¸€ä¸ªå˜é‡ä¸¤æ¬¡ã€‚ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ï¼Œç¬¬äºŒæ¬¡é˜»å¡ã€‚ç›´åˆ°å¤–éƒ¨å·¥å…·è§£å¼€è¿™ä¸ªé”ï¼Œçº¿ç¨‹æ‰ä¼šç»§ç»­ã€‚
2. zsim æ ¹æ®å½“å‰çš„æ¨¡æ‹Ÿæ¨¡å¼ï¼Œå†³å®šç»™è¿™ä¸ªæ–°çº¿ç¨‹åˆ†é…ä»€ä¹ˆæ ·çš„â€œå‡½æ•°æŒ‡é’ˆè¡¨â€ (fPtrs)ï¼š
    - å¿«è¿›æ¨¡å¼ (isInFastForward)ï¼šç»™çº¿ç¨‹è£…é…â€œå¿«è¿›ä¸“ç”¨â€çš„æ’æ¡©å‡½æ•°ï¼ˆåªè®¡æ•°ï¼Œä¸æ¨¡æ‹Ÿ Cache/Coreï¼‰ã€‚
    - å½±å­/æ³¨å†Œæ¨¡å¼ (registerThreads)ï¼šç»™çº¿ç¨‹è£…é…â€œç©ºæ“ä½œï¼ˆNOPï¼‰â€æ’æ¡©ã€‚å¦‚æœä½ åªå…³å¿ƒç¨‹åºçš„æŸä¸ªç‰¹å®šåŒºåŸŸï¼ˆROIï¼‰ã€‚çº¿ç¨‹è™½ç„¶å¯åŠ¨äº†ï¼Œä½†åœ¨ç¢°åˆ° Magic Op æ˜¾å¼â€œæ³¨å†Œâ€è‡ªå·±ä¹‹å‰ï¼Œzsim å½“å®ƒä¸å­˜åœ¨ï¼Œä¸æ¨¡æ‹Ÿå®ƒã€‚
    - æ­£å¸¸è¯¦ç»†æ¨¡æ‹Ÿ (Normal Start)ï¼šè°ƒç”¨ SimThreadStart(tid)

### SimThreadStart

çœŸæ­£çš„åˆå§‹åŒ–é€»è¾‘ï¼š

1. `zinfo->sched->start(...)`ï¼šè°ƒç”¨ Scheduler ç±»ï¼Œåœ¨ gidMap ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ ThreadInfo å¯¹è±¡ã€‚æ­¤æ—¶çº¿ç¨‹çŠ¶æ€è¢«è®¾ä¸º STARTEDï¼Œä½†è¿˜æ²¡æœ‰åˆ†é…ç‰©ç†æ ¸å¿ƒ (cid)ã€‚
2. `activeThreads[tid] = true;`ï¼šæ›´æ–°æœ¬åœ°çš„æ´»è·ƒä½å›¾ã€‚
3. `fPtrs[tid] = joinPtrs;`ï¼šæ–°çº¿ç¨‹ä¸èƒ½ç›´æ¥å†²è¿›æ¨¡æ‹Ÿå¾ªç¯ï¼Œå› ä¸ºå®ƒé”™è¿‡äº†å½“å‰ Phase çš„åŒæ­¥ç‚¹ã€‚joinPtrs æ˜¯ä¸€ç»„ç‰¹æ®Šçš„å‡½æ•°æŒ‡é’ˆï¼Œå®ƒä»¬ä¼šè®©çº¿ç¨‹åœ¨æ‰§è¡Œç¬¬ä¸€æ¡æŒ‡ä»¤æ—¶ï¼Œå¼ºåˆ¶è°ƒç”¨ Scheduler::join()ã€‚è¿™æ ·ï¼Œæ–°çº¿ç¨‹ä¼šå…ˆå»æ’é˜Ÿï¼Œé¢†å–ä¸€ä¸ª Core ID (cid)ï¼Œç­‰åˆ°ä¸‹ä¸€ä¸ª Phase å¼€å§‹æ—¶ï¼Œæ‰æ­£å¼åŠ å…¥æ¨¡æ‹Ÿå¤§å†›ã€‚
4. `clearCid(tid);`ï¼šç¡®ä¿ cids[tid] è¢«åˆå§‹åŒ–ä¸ºæ— æ•ˆå€¼ï¼Œç­‰å¾… Scheduler åˆ†é…ã€‚

### ThreadFini

å½“ç›®æ ‡çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼ˆpthread_exit æˆ–ä»çº¿ç¨‹å‡½æ•°è¿”å›ï¼‰æ—¶ï¼ŒPin è°ƒç”¨æ­¤å‡½æ•°ã€‚è°ƒç”¨æ—¶æœºï¼šçº¿ç¨‹å³å°†è¢«é”€æ¯ï¼Œæ­¤æ—¶å®ƒè¿˜å¯ä»¥æ‰§è¡Œä¸€äº›æ¸…ç†ä»£ç ã€‚

1. `if (fPtrs[tid].type == FPTR_NOP) { return; }`ï¼šæ£€æŸ¥è¿™ä¸ªçº¿ç¨‹æ˜¯ä¸æ˜¯ä¸€ä¸ªâ€œå½±å­çº¿ç¨‹â€ï¼ˆä»æœªè¢«æ¿€æ´»è¿‡ï¼‰ã€‚ç›´æ¥å¿½ç•¥ï¼Œå› ä¸ºå®ƒä»æœªåœ¨ Scheduler é‡Œæ³¨å†Œè¿‡ï¼Œä¸éœ€è¦æ³¨é”€ã€‚å¦åˆ™è°ƒç”¨ SimThreadFini(tid);

### SimThreadFini

1. `zinfo->sched->finish(procIdx, tid);`ï¼šæ³¨é”€è°ƒåº¦å™¨ã€‚
2. `activeThreads[tid] = false;`ã€`cids[tid] = UNINITIALIZED_CID;`ï¼šæ›´æ–°çŠ¶æ€ï¼Œé˜²æ­¢åç»­æœ‰é‡æŒ‡é’ˆé€šè¿‡ tid è®¿é—®åˆ°é”™è¯¯çš„æ ¸å¿ƒæ•°æ®ã€‚

### Fini

å½“è¢«æ¨¡æ‹Ÿçš„ç›®æ ‡ç¨‹åºï¼ˆGuest Applicationï¼‰æ‰§è¡Œå®Œæ¯•ï¼Œæˆ–è€… zsim å†³å®šå¼ºåˆ¶ç»“æŸæ¨¡æ‹Ÿæ—¶ï¼Œè¿™ä¸€å¥—æµç¨‹ä¼šè¢«è§¦å‘ã€‚å®ƒä»¬çš„ä»»åŠ¡æ˜¯ï¼šç¡®ä¿å¤šçº¿ç¨‹/å¤šè¿›ç¨‹ç¯å¢ƒä¸‹çš„å®‰å…¨é€€å‡ºï¼Œå¹¶å®Œæ•´åœ°ä¿å­˜ç»Ÿè®¡æ•°æ® (zsim.out)ã€‚

Fini(int code, VOID * v)ä»…ä»…æ˜¯ Pin çš„å›è°ƒå…¥å£ã€‚

### SimEnd

1. `if (__sync_bool_compare_and_swap(&perProcessEndFlag, 0, 1) == false)`: ä¸€ä¸ªè¿›ç¨‹å¯èƒ½æœ‰å¤šä¸ªçº¿ç¨‹ã€‚å½“è¿›ç¨‹å´©æºƒæˆ–è°ƒç”¨ exit_group æ—¶ï¼ŒPin å¯èƒ½ä¼šè®©å¤šä¸ªçº¿ç¨‹åŒæ—¶è§¦å‘ Fini / SimEndã€‚éœ€è¦ç¡®ä¿æ¯ä¸ªè¿›ç¨‹åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œæ¸…ç†é€»è¾‘ã€‚
2. `bool lastToFinish = procTreeNode->notifyEnd();`ï¼šå‘Šè¯‰å…¨å±€å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰è¿™ä¸ªè¿›ç¨‹å·²ç»ç»“æŸäº†ã€‚åŸå­é€’å‡ zinfo->globalActiveProcsï¼ˆå…¨å±€æ´»è·ƒè¿›ç¨‹æ•°ï¼‰ã€‚è¿”å›å¸ƒå°”å€¼ï¼šå¦‚æœå‡å®Œä¹‹åå˜æˆäº† 0ï¼Œè¯´æ˜æˆ‘æ˜¯å…¨ç³»ç»Ÿæœ€åä¸€ä¸ªç»“æŸçš„è¿›ç¨‹ã€‚
3. Process 0 æœ€ç»ˆå¤„ç†ã€‚åœ¨ zsim çš„å¤šè¿›ç¨‹æ¨¡å‹ä¸­ï¼Œè¿›ç¨‹ 0 (Process 0) è¢«æŒ‡å®šä¸ºâ€œç®¡å®¶â€ã€‚å…¶ä»–è¿›ç¨‹ï¼ˆProcess 1, 2...ï¼‰ç»“æŸæ—¶åªç®¡è‡ªå·±æ­»æ‰ï¼Œä½† Process 0 å¿…é¡»ç•™åˆ°æœ€åæ‰“æ‰«æˆ˜åœºã€‚
    1. `while (zinfo->globalActiveProcs) usleep(100*1000);`ï¼šç­‰å¾…å…¶ä»–è¿›ç¨‹ã€‚
    2. `for (StatsBackend* backend : ...) backend->dump(false);`ï¼šdumpç»Ÿè®¡æ•°æ®ã€‚
    3. `zinfo->sched->notifyTermination()`ï¼šå‘Šè¯‰è°ƒåº¦å™¨é‡Œçš„ Watchdog çº¿ç¨‹ï¼Œä¸ç”¨å†æŸ¥æ­»é”äº†ï¼Œä¸€åˆ‡è¦ç»“æŸäº†ã€‚

### SyscallEnter

å½“ç›®æ ‡ç¨‹åºæ‰§è¡Œ syscall æŒ‡ä»¤ä½†å°šæœªè¿›å…¥å†…æ ¸æ—¶ï¼ŒPin è°ƒç”¨æ­¤å‡½æ•°ã€‚

1. è§¦å‘è™šæ‹ŸåŒ–è¡¥ä¸ (Patching)ï¼šæ£€æŸ¥æ­¤ç³»ç»Ÿè°ƒç”¨æ˜¯å¦éœ€è¦è¢«æ‹¦æˆªæˆ–ä¿®æ”¹ã€‚
2. è°ƒåº¦å™¨é€šçŸ¥ (Scheduling)ï¼šå‘Šè¯‰è°ƒåº¦å™¨â€œæˆ‘è¦ç¦»å¼€ç”¨æˆ·æ€å»å†…æ ¸åŠäº‹äº†â€ï¼Œå¹¶äº¤è¿˜ CPU (leave)ã€‚

å­è¿‡ç¨‹ï¼š

1. `bool isNopThread = ...;`ã€`bool isRetryThread = ...;`ï¼šæ£€æŸ¥å½“å‰çº¿ç¨‹æ˜¯å¦æ˜¯â€œå½±å­çº¿ç¨‹â€ï¼ˆä¸æ¨¡æ‹Ÿï¼‰æˆ–è€…æ˜¯æ­£åœ¨â€œé‡è¯•â€æŸä¸ªè¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨ã€‚
2. `VirtSyscallEnter(tid, ctxt, std, ...);`ï¼špatché€»è¾‘çš„æ ¸å¿ƒå…¥å£
    - ä»£ç ä¸­åŒ…å«äº†é’ˆå¯¹ SYS_arch_prctl (CET protection) å’Œ SYS_clone3 çš„ç‰¹æ®Šå¤„ç†ã€‚ä¸ºäº†é˜²æ­¢ Pin å´©æºƒæˆ–å…¼å®¹ glibcï¼Œzsim ä¼šæ‰‹åŠ¨è·³è¿‡è¿™äº›æŒ‡ä»¤å¹¶è¿”å›é”™è¯¯ç ï¼Œå‡è£…å†…æ ¸ä¸æ”¯æŒè¿™äº›ç‰¹æ€§ã€‚
    - `postPatchFunctions[tid] = prePatchFunctions[syscall](...);`ï¼šæŸ¥è¡¨åˆ†å‘ï¼Œå®ƒä½¿ç”¨ç³»ç»Ÿè°ƒç”¨å· (syscall) ä½œä¸ºç´¢å¼•ï¼Œåœ¨ prePatchFunctions è¡¨ï¼ˆæˆ‘ä»¬åœ¨ VirtInit ä¸­è§è¿‡çš„ï¼‰ä¸­æŸ¥æ‰¾å¯¹åº”çš„å¤„ç†å‡½æ•°ã€‚
3. `if (fPtrs[tid].type != FPTR_JOIN && !zinfo->blockingSyscalls) { ... }`ï¼šå¦‚æœè¿™ä¸æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ Join çº¿ç¨‹ï¼Œä¸”é…ç½®ä¸å…è®¸é˜»å¡å¼ç³»ç»Ÿè°ƒç”¨ï¼ˆé»˜è®¤æƒ…å†µï¼‰ï¼š
    - äº¤è¿˜ CPU (syscallLeave)ï¼šè¿™å‘Šè¯‰è°ƒåº¦å™¨ï¼šï¼ˆçº¿ç¨‹ tidï¼‰æ­£åœ¨ç¦»å¼€ç”¨æˆ·æ€ã€‚æˆ‘ç°åœ¨å ç”¨çš„ç‰©ç†æ ¸å¿ƒ cid å¿…é¡»è¢«é‡Šæ”¾ï¼Œä»¥ä¾¿å…¶ä»–çº¿ç¨‹ä½¿ç”¨ã€‚clearCid(tid)ï¼šæ¸…é™¤æœ¬åœ°çš„æ ¸å¿ƒæ˜ å°„ã€‚
    - `fPtrs[tid] = joinPtrs;`ï¼šè®¾ç½®å½’æ¥åçš„è¡Œä¸º (joinPtrs)ï¼Œè¿™æ„å‘³ç€ï¼Œå½“ç³»ç»Ÿè°ƒç”¨è¿”å›å¹¶æ‰§è¡Œä¸‹ä¸€æ¡ç”¨æˆ·æ€æŒ‡ä»¤æ—¶ï¼Œè¯¥çº¿ç¨‹ä¸ä¼šç›´æ¥æ‰§è¡Œï¼Œè€Œæ˜¯ä¼šè°ƒç”¨ joinPtrs æŒ‡å‘çš„å‡½æ•°ï¼Œè¢«è¿«å»è°ƒåº¦å™¨é‚£é‡Œæ’é˜Ÿé‡æ–°ç”³è¯·æ ¸å¿ƒ (join)ã€‚

### SyscallExit

å½“ç³»ç»Ÿè°ƒç”¨å®Œæˆï¼Œå†…æ ¸å³å°†è¿”å›ç”¨æˆ·æ€æ—¶ï¼ŒPin è°ƒç”¨æ­¤å‡½æ•°ã€‚è§¦å‘è™šæ‹ŸåŒ–åå¤„ç† (Post-Patching)ï¼šå¤„ç†è¿”å›å€¼ï¼Œå†³å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨ã€‚æ¢å¤çŠ¶æ€ï¼šå†³å®šçº¿ç¨‹æ¥ä¸‹æ¥æ˜¯ç”¨ joinPtrs æ’é˜Ÿï¼Œè¿˜æ˜¯æ¢å¤æ­£å¸¸æ‰§è¡Œï¼Œäº¦æˆ–æ˜¯è¿›å…¥å¿«è¿›æ¨¡å¼ã€‚

å­è¿‡ç¨‹ï¼š

1. `PostPatchAction ppa = VirtSyscallExit(tid, ctxt, std);`ï¼šå®ƒç›´æ¥è°ƒç”¨ä¹‹å‰ä¿å­˜çš„ `postPatchFunctions[tid](...)`ã€‚ä¾‹å¦‚ï¼Œå¯¹äº SYS_futexï¼Œå®ƒçš„ Post-Patch å‡½æ•°å¯èƒ½ä¼šæ£€æŸ¥è¿”å›å€¼ã€‚å¦‚æœ futex å†³å®šé˜»å¡çº¿ç¨‹ï¼ŒPost-Patch å‡½æ•°ä¼šå‘Šè¯‰è°ƒåº¦å™¨â€œè¿™ä¸ªçº¿ç¨‹ç¡ç€äº†â€ã€‚è¿”å›å€¼ ppaï¼šè¿™æ˜¯ä¸€ä¸ªåŠ¨ä½œæŒ‡ä»¤ï¼ˆActionï¼‰ï¼Œå‘Šè¯‰ SyscallExit ä¸‹ä¸€æ­¥è¯¥æ€ä¹ˆåšã€‚
2. ä¸‹ä¸€æ­¥ï¼š
    - PPA_USE_JOIN_PTRSï¼šæ„å‘³ç€ç³»ç»Ÿè°ƒç”¨æ­£å¸¸ç»“æŸã€‚è®¾ç½® fPtrs[tid] = joinPtrsã€‚çº¿ç¨‹å›åˆ°ç”¨æˆ·æ€çš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯å»è°ƒåº¦å™¨æ’é˜Ÿ (join)ã€‚ç‰¹ä¾‹ï¼šå¦‚æœ blockingSyscalls ä¸ºçœŸï¼ˆå°‘è§é…ç½®ï¼‰ï¼Œåˆ™ç›´æ¥æ¢å¤ GetFuncPtrs()ï¼Œä¸æ’é˜Ÿã€‚
    - PPA_USE_RETRY_PTRSï¼šæ„å‘³ç€ç³»ç»Ÿè°ƒç”¨è¢«ä¿¡å·ä¸­æ–­ï¼ˆEINTRï¼‰ï¼Œéœ€è¦é‡è¯•ã€‚è®¾ç½® fPtrs[tid] = retryPtrsã€‚
3. `if (fPtrs[tid].type == FPTR_JOIN && procTreeNode->isInFastForward()) { ... }`ï¼šFast-forwardingæ£€æŸ¥ã€‚å¦‚æœçº¿ç¨‹åœ¨ç³»ç»Ÿè°ƒç”¨æœŸé—´ï¼Œæ¨¡æ‹Ÿå™¨åˆ‡æ¢åˆ°äº†å¿«è¿›æ¨¡å¼ (Fast Forward)ã€‚é‚£ä¹ˆçº¿ç¨‹å°±ä¸åº”è¯¥å†å» joinï¼ˆæ’é˜Ÿç­‰å¾…æ¨¡æ‹Ÿæ ¸å¿ƒï¼‰äº†ï¼Œå› ä¸ºå¿«è¿›æ¨¡å¼ä¸‹ä¸éœ€è¦æ ¸å¿ƒã€‚
    - `SimThreadFini(tid)`ï¼šåœ¨ Scheduler é‡Œæ³¨é”€ï¼ˆå› ä¸ºå¿«è¿›æ¨¡å¼ä¸éœ€è¦ Scheduler ç®¡ç†ï¼‰ã€‚
    - `fPtrs[tid] = GetFFPtrs()`ï¼šç›´æ¥åˆ‡æ¢åˆ°å¿«è¿›æ’æ¡©å‡½æ•°ã€‚
4. å¦‚æœ `zinfo->terminationConditionMet` ä¸ºçœŸï¼ˆä¾‹å¦‚æŸä¸ªè¿›ç¨‹è°ƒç”¨äº† exit_groupï¼‰ï¼Œåˆ™è°ƒç”¨ SimEnd() ç»“æŸæ•´ä¸ªæ¨¡æ‹Ÿã€‚

### ContextChange

åœ¨æ­£å¸¸çš„æ¨¡æ‹Ÿæµç¨‹ä¸­ï¼Œç¨‹åºæŒ‰ç…§â€œåŸºæœ¬å— -> ç³»ç»Ÿè°ƒç”¨ -> åŸºæœ¬å—â€çš„é¡ºåºæ‰§è¡Œã€‚ä½†æ˜¯ï¼Œä¿¡å·ï¼ˆSignalsï¼‰çš„å­˜åœ¨æ‰“ç ´äº†è¿™ç§é¡ºåºã€‚å½“æ“ä½œç³»ç»Ÿå‘è¿›ç¨‹å‘é€ä¿¡å·ï¼ˆæ¯”å¦‚ SIGSEGV æ®µé”™è¯¯ï¼Œæˆ–è€… SIGINT ä¸­æ–­ï¼‰æ—¶ï¼Œç¨‹åºçš„æ§åˆ¶æµä¼šçªç„¶ä»å½“å‰ä½ç½®â€œç¬ç§»â€åˆ°ä¿¡å·å¤„ç†å‡½æ•°ï¼Œæˆ–è€…ç›´æ¥è¢«ç»ˆæ­¢ã€‚

ContextChange å°±æ˜¯ Intel Pin æä¾›çš„ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œç”¨æ¥é€šçŸ¥ zsim å‘ç”Ÿäº†éæ­£å¸¸çš„ä¸Šä¸‹æ–‡è·³è½¬ï¼ˆä¸æ˜¯æ™®é€šçš„å‡½æ•°è°ƒç”¨æˆ–è·³è½¬ï¼‰ã€‚

```c++
warn("[%d] ContextChange, reason %s, inSyscall %d", tid, reasonStr, inSyscall[tid]);
if (inSyscall[tid]) {
    SyscallExit(tid, to, SYSCALL_STANDARD_IA32E_LINUX, nullptr);
}
```

zsim åœ¨ SyscallEnter æ—¶ä¼šå°† inSyscall[tid] è®¾ä¸º trueã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼ŒSyscallExit ä¼šå°†å…¶è®¾å› falseã€‚å¦‚æœç³»ç»Ÿè°ƒç”¨è¢«ä¿¡å·æ‰“æ–­ï¼ˆä¾‹å¦‚ EINTRï¼‰ï¼ŒPin å¯èƒ½ä¸ä¼šè§¦å‘æ ‡å‡†çš„ SyscallExit å›è°ƒï¼Œè€Œæ˜¯ç›´æ¥è§¦å‘ ContextChange è·³è½¬åˆ°ä¿¡å·å¤„ç†å‡½æ•°ã€‚å¦‚æœä¸å¤„ç†ï¼ŒinSyscall[tid] ä¼šä¸€ç›´ä¿ç•™ä¸º trueã€‚ç­‰ä¿¡å·å¤„ç†å®Œå›åˆ°ä¸»ç¨‹åºï¼Œä¸‹ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œzsim ä¼šæ–­è¨€å¤±è´¥ï¼ˆassert falseï¼‰æˆ–è€…é€»è¾‘é”™ä¹±ã€‚åœ¨è¿™é‡Œå¼ºåˆ¶æ‰‹åŠ¨è°ƒç”¨ SyscallExitã€‚è¿™ç›¸å½“äºå¸® zsim â€œæ‰“è¡¥ä¸â€ï¼Œå¼ºè¡Œç»“æŸä¸Šä¸€ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ¨¡æ‹ŸçŠ¶æ€ï¼Œç¡®ä¿çŠ¶æ€æœºå¤ä½ã€‚

```c++
if (reason == CONTEXT_CHANGE_REASON_FATALSIGNAL) {
    info("[%d] Fatal signal caught, finishing", tid);
    zinfo->sched->queueProcessCleanup(procIdx, getpid());
    SimEnd();
}
```

å¦‚æœå‘ç”Ÿäº†æ®µé”™è¯¯ï¼ŒqueueProcessCleanupï¼šé€šçŸ¥è°ƒåº¦å™¨æ¸…ç†è¿™ä¸ªè¿›ç¨‹çš„é—ä½“ï¼ˆé‡Šæ”¾æ ¸å¿ƒã€ç§»é™¤çº¿ç¨‹ç»“æ„ï¼‰ã€‚SimEnd()ï¼šè¿™éå¸¸é‡è¦ã€‚å³ä½¿ç¨‹åºå´©æºƒäº†ï¼Œzsim ä¹Ÿå¸Œæœ›èƒ½å¤ŸæŠŠå·²ç»æ”¶é›†åˆ°çš„ç»Ÿè®¡æ•°æ®ï¼ˆzsim.outï¼‰å†™ç›˜ä¿å­˜ï¼Œè€Œä¸æ˜¯ç›´æ¥éšç¨‹åºä¸€èµ·æ¶ˆå¤±ã€‚è¿™è®©ç”¨æˆ·èƒ½çœ‹åˆ°â€œå´©æºƒå‰åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆâ€ã€‚

### PinCmd

### ContentionSim

### EventQueue

### Scheduler

### EndOfPhaseActions

### TakeBarrier

### AggregateStat

### PortVirtualizer

### NUMAMap

### ProcessStats

### ProcStats

### 